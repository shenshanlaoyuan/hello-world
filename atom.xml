<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>深山老猿</title>
  <icon>https://www.gravatar.com/avatar/337c5b9715d60466924c746da7df8603</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shenshanlaoyuan.com/"/>
  <updated>2020-05-09T03:31:03.971Z</updated>
  <id>http://shenshanlaoyuan.com/</id>
  
  <author>
    <name>深山老猿</name>
    <email>wl4j@foxmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>es生产集群的部署架构是什么？</title>
    <link href="http://shenshanlaoyuan.com/2020/05/09/%E9%9D%A2%E8%AF%95/2020-5-9-es%E7%94%9F%E4%BA%A7%E9%9B%86%E7%BE%A4%E7%9A%84%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/05/09/面试/2020-5-9-es生产集群的部署架构是什么？/</id>
    <published>2020-05-09T03:52:00.000Z</published>
    <updated>2020-05-09T03:31:03.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>es 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>这个问题，包括后面的 redis 什么的，谈到 es、redis、mysql 分库分表等等技术，面试必问！就是你生产环境咋部署的？说白了，这个问题没啥技术含量，就是看你有没有在真正的生产环境里干过这事儿！</p><p>有些同学可能是没在生产环境中干过的，没实际去拿线上机器部署过 es 集群，也没实际玩儿过，也没往 es 集群里面导入过几千万甚至是几亿的数据量，可能你就不太清楚这里面的一些生产项目中的细节。</p><p>如果你是自己就玩儿过 demo，没碰过真实的 es 集群，那你可能此时会懵。别懵，你一定要云淡风轻的回答出来这个问题，表示你确实干过这事儿。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/05/09/面试/2020-5-9-es生产集群的部署架构是什么？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/05/09/面试/2020-5-9-es生产集群的部署架构是什么？/'>es生产集群的部署架构是什么？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script> <h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>其实这个问题没啥，如果你确实干过 es，那你肯定了解你们生产 es 集群的实际情况，部署了几台机器？有多少个索引？每个索引有多大数据量？每个索引给了多少个分片？你肯定知道！</p><p>但是如果你确实没干过，也别虚，我给你说一个基本的版本，你到时候就简单说一下就好了。</p><ul><li>es 生产集群我们部署了 5 台机器，每台机器是 6 核 64G 的，集群总内存是 320G。</li><li>我们 es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，15G。目前系统已经运行了几个月，现在 es 集群里数据总量大概是 100G 左右。</li><li>目前线上有 5 个索引（这个结合你们自己业务来，看看自己有哪些数据可以放 es 的），每个索引的数据量大概是 20G，所以这个数据量之内，我们每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。</li></ul><p>大概就这么说一下就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;es 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;这个问题，包括后面的 redis 什么的，谈到 es、redis、mysql 分库分表等等技术，面试必问！就是你生产环境咋部署的？说白了，这个问题没啥技术含量，就是看你有没有在真正的生产环境里干过这事儿！&lt;/p&gt;
&lt;p&gt;有些同学可能是没在生产环境中干过的，没实际去拿线上机器部署过 es 集群，也没实际玩儿过，也没往 es 集群里面导入过几千万甚至是几亿的数据量，可能你就不太清楚这里面的一些生产项目中的细节。&lt;/p&gt;
&lt;p&gt;如果你是自己就玩儿过 demo，没碰过真实的 es 集群，那你可能此时会懵。别懵，你一定要云淡风轻的回答出来这个问题，表示你确实干过这事儿。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="搜索引擎" scheme="http://shenshanlaoyuan.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>es在数十亿级别数量下如何提高查询效率？</title>
    <link href="http://shenshanlaoyuan.com/2020/05/08/%E9%9D%A2%E8%AF%95/2020-5-8-es%E5%9C%A8%E6%95%B0%E5%8D%81%E4%BA%BF%E7%BA%A7%E5%88%AB%E6%95%B0%E9%87%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/05/08/面试/2020-5-8-es在数十亿级别数量下如何提高查询效率？/</id>
    <published>2020-05-08T03:52:00.000Z</published>
    <updated>2020-05-09T03:29:30.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>es 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>这个问题是肯定要问的，说白了，就是看你有没有实际干过 es，因为啥？其实 es 性能并没有你想象中那么好的。很多时候数据量大了，特别是有几亿条数据的时候，可能你会懵逼的发现，跑个搜索怎么一下 <code>5~10s</code>，坑爹了。第一次搜索的时候，是  <code>5~10s</code>，后面反而就快了，可能就几百毫秒。</p><p>你就很懵，每个用户第一次访问都会比较慢，比较卡么？所以你要是没玩儿过 es，或者就是自己玩玩儿 demo，被问到这个问题容易懵逼，显示出你对 es 确实玩儿的不怎么样？</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/05/08/面试/2020-5-8-es在数十亿级别数量下如何提高查询效率？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/05/08/面试/2020-5-8-es在数十亿级别数量下如何提高查询效率？/'>es在数十亿级别数量下如何提高查询效率？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script> <h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>说实话，es 性能优化是没有什么银弹的，啥意思呢？就是<strong>不要期待着随手调一个参数，就可以万能的应对所有的性能慢的场景</strong>。也许有的场景是你换个参数，或者调整一下语法，就可以搞定，但是绝对不是所有场景都可以这样。</p><h3 id="性能优化的杀手锏——filesystem-cache"><a href="#性能优化的杀手锏——filesystem-cache" class="headerlink" title="性能优化的杀手锏——filesystem cache"></a>性能优化的杀手锏——filesystem cache</h3><p>你往 es 里写的数据，实际上都写到磁盘文件里去了，<strong>查询的时候</strong>，操作系统会将磁盘文件里的数据自动缓存到 <code>filesystem cache</code> 里面去。</p><p><img src="https://i.loli.net/2020/05/08/RcFSKDZ3BmpA2q4.png" alt="es-search-process.png"></p><p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code>，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file</code> 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p><p>性能差距究竟可以有多大？我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1秒、5秒、10秒。但如果是走 <code>filesystem cache</code>，是走纯内存的，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。</p><p>这里有个真实的案例。某个公司 es 节点有 3 台机器，每台机器看起来内存很多，64G，总内存就是 <code>64 * 3 = 192G</code>。每台机器给 es jvm heap 是 <code>32G</code>，那么剩下来留给 <code>filesystem cache</code> 的就是每台机器才 <code>32G</code>，总共集群里给 <code>filesystem cache</code> 的就是 <code>32 * 3 = 96G</code> 内存。而此时，整个磁盘上索引数据文件，在 3 台机器上一共占用了 <code>1T</code> 的磁盘容量，es 数据量是 <code>1T</code>，那么每台机器的数据量是 <code>300G</code>。这样性能好吗？ <code>filesystem cache</code> 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差。</p><p>归根结底，你要让 es 性能要好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</p><p>根据我们自己的生产环境实践经验，最佳的情况下，是仅仅在 es 中就存少量的数据，就是你要<strong>用来搜索的那些索引</strong>，如果内存留给 <code>filesystem cache</code> 的是 100G，那么你就将索引数据控制在 <code>100G</code> 以内，这样的话，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。</p><p>比如说你现在有一行数据。<code>id,name,age ....</code> 30 个字段。但是你现在搜索，只需要根据 <code>id,name,age</code> 三个字段来搜索。如果你傻乎乎往 es 里写入一行数据所有的字段，就会导致说 <code>90%</code> 的数据是不用来搜索的，结果硬是占据了 es 机器上的 <code>filesystem cache</code> 的空间，单条数据的数据量越大，就会导致 <code>filesystem cahce</code> 能缓存的数据就越少。其实，仅仅写入 es 中要用来检索的<strong>少数几个字段</strong>就可以了，比如说就写入 es <code>id,name,age</code> 三个字段，然后你可以把其他的字段数据存在 mysql/hbase 里，我们一般是建议用 <code>es + hbase</code> 这么一个架构。</p><p>hbase 的特点是<strong>适用于海量数据的在线存储</strong>，就是对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 <code>doc id</code>，然后根据 <code>doc id</code> 到 hbase 里去查询每个 <code>doc id</code> 对应的<strong>完整的数据</strong>，给查出来，再返回给前端。</p><p>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 es，会每次查询都是 5~10s，现在可能性能就会很高，每次查询就是 50ms。</p><h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 <code>filesystem cache</code> 一倍，比如说你写入一台机器 60G 数据，结果 <code>filesystem cache</code> 就 30G，还是有 30G 数据留在了磁盘上。</p><p>其实可以做<strong>数据预热</strong>。</p><p>举个例子，拿微博来说，你可以把一些大V，平时看的人很多的数据，你自己提前后台搞个系统，每隔一会儿，自己的后台系统去搜索一下热数据，刷到 <code>filesystem cache</code> 里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。</p><p>或者是电商，你可以将平时查看最多的一些商品，比如说 iphone 8，热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 <code>filesystem cache</code> 里去。</p><p>对于那些你觉得比较热的、经常会有人访问的数据，最好<strong>做一个专门的缓存预热子系统</strong>，就是对热数据每隔一段时间，就提前访问一下，让数据进入 <code>filesystem cache</code> 里面去。这样下次别人访问的时候，性能一定会好很多。</p><h3 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h3><p>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将<strong>冷数据写入一个索引中，然后热数据写入另外一个索引中</strong>，这样可以确保热数据在被预热之后，尽量都让他们留在 <code>filesystem os cache</code> 里，<strong>别让冷数据给冲刷掉</strong>。</p><p>你看，假设你有 6 台机器，2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。3 台机器放热数据 index，另外 3 台机器放冷数据 index。然后这样的话，你大量的时间是在访问热数据 index，热数据可能就占总数据量的 10%，此时数据量很少，几乎全都保留在 <code>filesystem cache</code> 里面了，就可以确保热数据的访问性能是很高的。但是对于冷数据而言，是在别的 index 里的，跟热数据 index 不在相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就 10% 的人去访问冷数据，90% 的人在访问热数据，也无所谓了。</p><h3 id="document-模型设计"><a href="#document-模型设计" class="headerlink" title="document 模型设计"></a>document 模型设计</h3><p>对于 MySQL，我们经常有一些复杂的关联查询。在 es 里该怎么玩儿，es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。</p><p>最好是先在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。</p><p>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join/nested/parent-child 搜索都要尽量避免，性能都很差的。</p><h3 id="分页性能优化"><a href="#分页性能优化" class="headerlink" title="分页性能优化"></a>分页性能优化</h3><p>es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p><p>分布式的，你要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据吧？你<strong>必须</strong>得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。</p><p>我们之前也是遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10 秒才能查出来一页数据了。</p><p>有什么解决方案吗？</p><h4 id="不允许深度分页（默认深度分页性能很差）"><a href="#不允许深度分页（默认深度分页性能很差）" class="headerlink" title="不允许深度分页（默认深度分页性能很差）"></a>不允许深度分页（默认深度分页性能很差）</h4><p>跟产品经理说，你系统不允许翻那么深的页，默认翻的越深，性能就越差。</p><h4 id="类似于-app-里的推荐商品不断下拉出来一页一页的"><a href="#类似于-app-里的推荐商品不断下拉出来一页一页的" class="headerlink" title="类似于 app 里的推荐商品不断下拉出来一页一页的"></a>类似于 app 里的推荐商品不断下拉出来一页一页的</h4><p>类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 <code>scroll api</code>，关于如何使用，自行上网搜索。</p><p>scroll 会一次性给你生成<strong>所有数据的一个快照</strong>，然后每次滑动向后翻页就是通过<strong>游标</strong> <code>scroll_id</code> 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。</p><p>但是，唯一的一点就是，这个适合于那种类似微博下拉翻页的，<strong>不能随意跳到任何一页的场景</strong>。也就是说，你不能先进入第 10 页，然后去第 120 页，然后又回到第 58 页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻。</p><p>初始化时必须指定 <code>scroll</code> 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</p><p>除了用 <code>scroll api</code>，你也可以用 <code>search_after</code> 来做，<code>search_after</code> 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;es 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;这个问题是肯定要问的，说白了，就是看你有没有实际干过 es，因为啥？其实 es 性能并没有你想象中那么好的。很多时候数据量大了，特别是有几亿条数据的时候，可能你会懵逼的发现，跑个搜索怎么一下 &lt;code&gt;5~10s&lt;/code&gt;，坑爹了。第一次搜索的时候，是  &lt;code&gt;5~10s&lt;/code&gt;，后面反而就快了，可能就几百毫秒。&lt;/p&gt;
&lt;p&gt;你就很懵，每个用户第一次访问都会比较慢，比较卡么？所以你要是没玩儿过 es，或者就是自己玩玩儿 demo，被问到这个问题容易懵逼，显示出你对 es 确实玩儿的不怎么样？&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="搜索引擎" scheme="http://shenshanlaoyuan.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>es写入数据的工作原理是什么？</title>
    <link href="http://shenshanlaoyuan.com/2020/05/07/%E9%9D%A2%E8%AF%95/2020-5-7-es%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/05/07/面试/2020-5-7-es写入数据的工作原理是什么？/</id>
    <published>2020-05-07T03:52:00.000Z</published>
    <updated>2020-05-09T03:27:22.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>es 写入数据的工作原理是什么啊？es 查询数据的工作原理是什么啊？底层的 lucene 介绍一下呗？倒排索引了解吗？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>问这个，其实面试官就是要看看你了解不了解 es 的一些基本原理，因为用 es 无非就是写入数据，搜索数据。你要是不明白你发起一个写入和搜索请求的时候，es 在干什么，那你真的是……</p><p>对 es 基本就是个黑盒，你还能干啥？你唯一能干的就是用 es 的 api 读写数据了。要是出点什么问题，你啥都不知道，那还能指望你什么呢？</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/05/07/面试/2020-5-7-es写入数据的工作原理是什么？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/05/07/面试/2020-5-7-es写入数据的工作原理是什么？/'>es写入数据的工作原理是什么？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script> <h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><h3 id="es-写数据过程"><a href="#es-写数据过程" class="headerlink" title="es 写数据过程"></a>es 写数据过程</h3><ul><li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code>（协调节点）。</li><li><code>coordinating node</code> 对 document 进行<strong>路由</strong>，将请求转发给对应的 node（有 primary shard）。</li><li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code>。</li><li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li></ul><p><img src="https://i.loli.net/2020/05/08/p9ksHJPVRUafX71.png" alt="es-write.png"></p><h3 id="es-读数据过程"><a href="#es-读数据过程" class="headerlink" title="es 读数据过程"></a>es 读数据过程</h3><p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ul><li>客户端发送请求到<strong>任意</strong>一个 node，成为 <code>coordinate node</code>。</li><li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code> <strong>随机轮询算法</strong>，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给 <code>coordinate node</code>。</li><li><code>coordinate node</code> 返回 document 给客户端。</li></ul><h3 id="es-搜索数据过程"><a href="#es-搜索数据过程" class="headerlink" title="es 搜索数据过程"></a>es 搜索数据过程</h3><p>es 最强大的是做全文检索，就是比如你有三条数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java真好玩儿啊</div><div class="line">java好难学啊</div><div class="line">j2ee特别牛</div></pre></td></tr></table></figure></p><p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code>的 <code>document</code> 给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。</p><ul><li>客户端发送请求到一个 <code>coordinate node</code>。</li><li>协调节点将搜索请求转发到<strong>所有</strong>的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code>，都可以。</li><li>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code>）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li><li>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li></ul><blockquote><p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p></blockquote><h3 id="写数据底层原理"><a href="#写数据底层原理" class="headerlink" title="写数据底层原理"></a>写数据底层原理</h3><p><img src="https://i.loli.net/2020/05/08/hOF1Ju86EYjlQem.png" alt="es-write-detail.png"></p><p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p><p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 <code>refresh</code> 到一个新的 <code>segment file</code> 中，但是此时数据不是直接进入 <code>segment file</code> 磁盘文件，而是先进入 <code>os cache</code> 。这个过程就是 <code>refresh</code>。</p><p>每隔 1 秒钟，es 将 buffer 中的数据写入一个<strong>新的</strong> <code>segment file</code>，每秒钟会产生一个<strong>新的磁盘文件</strong> <code>segment file</code>，这个 <code>segment file</code> 中就存储最近 1 秒内 buffer 中写入的数据。</p><p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p><p>操作系统里面，磁盘文件其实都有一个东西，叫做 <code>os cache</code>，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 <code>os cache</code>，先进入操作系统级别的一个内存缓存中去。只要 <code>buffer</code> 中的数据被 refresh 操作刷入 <code>os cache</code>中，这个数据就可以被搜索到了。</p><p>为什么叫 es 是<strong>准实时</strong>的？ <code>NRT</code>，全称 <code>near real-time</code>。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 <code>restful api</code> 或者 <code>java api</code>，<strong>手动</strong>执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 <code>os cache</code>中，让数据立马就可以被搜索到。只要数据被输入 <code>os cache</code> 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p><p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 <code>buffer</code> 数据写入一个又一个新的 <code>segment file</code> 中去，每次 <code>refresh</code> 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 <code>commit</code> 操作。</p><p>commit 操作发生第一步，就是将 buffer 中现有数据 <code>refresh</code> 到 <code>os cache</code> 中去，清空 buffer。然后，将一个 <code>commit point</code> 写入磁盘文件，里面标识着这个 <code>commit point</code> 对应的所有 <code>segment file</code>，同时强行将 <code>os cache</code> 中目前所有的数据都 <code>fsync</code> 到磁盘文件中去。最后<strong>清空</strong> 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p><p>这个 commit 操作叫做 <code>flush</code>。默认 30 分钟自动执行一次 <code>flush</code>，但如果 translog 过大，也会触发 <code>flush</code>。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p><p>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 <code>translog</code> 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p><p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会<strong>丢失</strong> 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 <code>fsync</code> 到磁盘，但是性能会差很多。</p><p>实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的<strong>数据丢失</strong>。</p><p><strong>总结一下</strong>，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p><blockquote><p>数据写入 segment file 之后，同时就建立好了倒排索引。</p></blockquote><h3 id="删除-更新数据底层原理"><a href="#删除-更新数据底层原理" class="headerlink" title="删除/更新数据底层原理"></a>删除/更新数据底层原理</h3><p>如果是删除操作，commit 的时候会生成一个 <code>.del</code> 文件，里面将某个 doc 标识为 <code>deleted</code> 状态，那么搜索的时候根据 <code>.del</code> 文件就知道这个 doc 是否被删除了。</p><p>如果是更新操作，就是将原来的 doc 标识为 <code>deleted</code> 状态，然后新写入一条数据。</p><p>buffer 每 refresh 一次，就会产生一个 <code>segment file</code>，所以默认情况下是 1 秒钟一个 <code>segment file</code>，这样下来 <code>segment file</code> 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 <code>segment file</code> 合并成一个，同时这里会将标识为 <code>deleted</code> 的 doc 给<strong>物理删除掉</strong>，然后将新的 <code>segment file</code> 写入磁盘，这里会写一个 <code>commit point</code>，标识所有新的 <code>segment file</code>，然后打开 <code>segment file</code> 供搜索使用，同时删除旧的 <code>segment file</code>。</p><h3 id="底层-lucene"><a href="#底层-lucene" class="headerlink" title="底层 lucene"></a>底层 lucene</h3><p>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</p><p>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。</p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</p><p>那么，倒排索引就是<strong>关键词到文档</strong> ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</p><p>举个栗子。</p><p>有以下文档：</p><table><thead><tr><th>DocId</th><th>Doc</th></tr></thead><tbody><tr><td>1</td><td>谷歌地图之父跳槽 Facebook</td></tr><tr><td>2</td><td>谷歌地图之父加盟 Facebook</td></tr><tr><td>3</td><td>谷歌地图创始人拉斯离开谷歌加盟 Facebook</td></tr><tr><td>4</td><td>谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关</td></tr><tr><td>5</td><td>谷歌地图之父拉斯加盟社交网站 Facebook</td></tr></tbody></table><p>对文档进行分词之后，得到以下<strong>倒排索引</strong>。</p><table><thead><tr><th>WordId</th><th>Word</th><th>DocIds</th></tr></thead><tbody><tr><td>1</td><td>谷歌</td><td>1,2,3,4,5</td></tr><tr><td>2</td><td>地图</td><td>1,2,3,4,5</td></tr><tr><td>3</td><td>之父</td><td>1,2,4,5</td></tr><tr><td>4</td><td>跳槽</td><td>1,4</td></tr><tr><td>5</td><td>Facebook</td><td>1,2,3,4,5</td></tr><tr><td>6</td><td>加盟</td><td>2,3,5</td></tr><tr><td>7</td><td>创始人</td><td>3</td></tr><tr><td>8</td><td>拉斯</td><td>3,5</td></tr><tr><td>9</td><td>离开</td><td>3</td></tr><tr><td>10</td><td>与</td><td>4</td></tr><tr><td>..</td><td>..</td><td>..</td></tr></tbody></table><p>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。</p><p>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 <code>Facebook</code>，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</p><p>要注意倒排索引的两个重要细节：</p><ul><li>倒排索引中的所有词项对应一个或多个文档；</li><li>倒排索引中的词项<strong>根据字典顺序升序排列</strong></li></ul><blockquote><p>上面只是一个简单的栗子，并没有严格按照字典顺序升序排列。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;es 写入数据的工作原理是什么啊？es 查询数据的工作原理是什么啊？底层的 lucene 介绍一下呗？倒排索引了解吗？&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;问这个，其实面试官就是要看看你了解不了解 es 的一些基本原理，因为用 es 无非就是写入数据，搜索数据。你要是不明白你发起一个写入和搜索请求的时候，es 在干什么，那你真的是……&lt;/p&gt;
&lt;p&gt;对 es 基本就是个黑盒，你还能干啥？你唯一能干的就是用 es 的 api 读写数据了。要是出点什么问题，你啥都不知道，那还能指望你什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="搜索引擎" scheme="http://shenshanlaoyuan.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>es的分布式架构原理是什么？</title>
    <link href="http://shenshanlaoyuan.com/2020/05/06/%E9%9D%A2%E8%AF%95/2020-5-6-es%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/05/06/面试/2020-5-6-es的分布式架构原理是什么？/</id>
    <published>2020-05-06T03:52:00.000Z</published>
    <updated>2020-05-09T03:25:27.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>es 的分布式架构原理能说一下么（es 是如何实现分布式的啊）？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>在搜索这块，lucene 是最流行的搜索库。几年前业内一般都问，你了解 lucene 吗？你知道倒排索引的原理吗？现在早已经 out 了，因为现在很多项目都是直接用基于 lucene 的分布式搜索引擎—— ElasticSearch，简称为 es。</p><p>而现在分布式搜索基本已经成为大部分互联网行业的 Java 系统的标配，其中尤为流行的就是 es，前几年 es 没火的时候，大家一般用 solr。但是这两年基本大部分企业和项目都开始转向 es 了。</p><p>所以互联网面试，肯定会跟你聊聊分布式搜索引擎，也就一定会聊聊 es，如果你确实不知道，那你真的就 out 了。</p><p>如果面试官问你第一个问题，确实一般都会问你 es 的分布式架构设计能介绍一下么？就看看你对分布式搜索引擎架构的一个基本理解。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/05/06/面试/2020-5-6-es的分布式架构原理是什么？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/05/06/面试/2020-5-6-es的分布式架构原理是什么？/'>es的分布式架构原理是什么？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script> <h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>ElasticSearch 设计的理念就是分布式搜索引擎，底层其实还是基于 lucene 的。核心思想就是在多台机器上启动多个 es 进程实例，组成了一个 es 集群。</p><p>es 中存储数据的<strong>基本单位是索引</strong>，比如说你现在要在 es 中存储一些订单数据，你就应该在 es 中创建一个索引 <code>order_idx</code>，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一张表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">index -&gt; type -&gt; mapping -&gt; document -&gt; field。</div></pre></td></tr></table></figure><p>这样吧，为了做个更直白的介绍，我在这里做个类比。但是切记，不要划等号，类比只是为了便于理解。</p><p>index 相当于 mysql 里的一张表。而 type 没法跟 mysql 里去对比，一个 index 里可以有多个 type，每个 type 的字段都是差不多的，但是有一些略微的差别。假设有一个 index，是订单 index，里面专门是放订单数据的。就好比说你在 mysql 中建表，有些订单是实物商品的订单，比如一件衣服、一双鞋子；有些订单是虚拟商品的订单，比如游戏点卡，话费充值。就两种订单大部分字段是一样的，但是少部分字段可能有略微的一些差别。</p><p>所以就会在订单 index 里，建两个 type，一个是实物商品订单 type，一个是虚拟商品订单 type，这两个 type 大部分字段是一样的，少部分字段是不一样的。</p><p>很多情况下，一个 index 里可能就一个 type，但是确实如果说是一个 index 里有多个 type 的情况（<strong>注意</strong>，<code>mapping types</code> 这个概念在 ElasticSearch 7.X 已被完全移除，详细说明可以参考<a href="https://github.com/elastic/elasticsearch/blob/6.5/docs/reference/mapping/removal_of_types.asciidoc" target="_blank" rel="external">官方文档</a>），你可以认为 index 是一个类别的表，具体的每个 type 代表了 mysql 中的一个表。每个 type 有一个 mapping，如果你认为一个 type 是具体的一个表，index 就代表多个 type 同属于的一个类型，而 mapping 就是这个 type 的<strong>表结构定义</strong>，你在 mysql 中创建一个表，肯定是要定义表结构的，里面有哪些字段，每个字段是什么类型。实际上你往 index 里的一个 type 里面写的一条数据，叫做一条 document，一条 document 就代表了 mysql 中某个表里的一行，每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值。</p><p><img src="https://i.loli.net/2020/05/08/O9yIbMBFgJHTLZK.png" alt="es-index-type-mapping-document-field.png"></p><p>你搞一个索引，这个索引可以拆分成多个 <code>shard</code>，每个 shard 存储部分数据。拆分多个 shard 是有好处的，一是<strong>支持横向扩展</strong>，比如你数据量是 3T，3 个 shard，每个 shard 就 1T 的数据，若现在数据量增加到 4T，怎么扩展，很简单，重新建一个有 4 个 shard 的索引，将数据导进去；二是<strong>提高性能</strong>，数据分布在多个 shard，即多台服务器上，所有的操作，都会在多台机器上并行分布式执行，提高了吞吐量和性能。</p><p>接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 <code>primary shard</code>，负责写入数据，但是还有几个 <code>replica shard</code>。<code>primary shard</code> 写入数据之后，会将数据同步到其他几个 <code>replica shard</code> 上去。</p><p><img src="https://i.loli.net/2020/05/08/hriGbvP14WmxHlf.png" alt="es-cluster.png"></p><p>通过这个 replica 的方案，每个 shard 的数据都有多个备份，如果某个机器宕机了，没关系啊，还有别的数据副本在别的机器上呢。高可用了吧。</p><p>es 集群多个节点，会自动选举一个节点为 master 节点，这个 master 节点其实就是干一些管理的工作的，比如维护索引元数据、负责切换 primary shard 和 replica shard 身份等。要是 master 节点宕机了，那么会重新选举一个节点为 master 节点。</p><p>如果是非 master节点宕机了，那么会由 master 节点，让那个宕机节点上的 primary shard 的身份转移到其他机器上的 replica shard。接着你要是修复了那个宕机机器，重启了之后，master 节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。</p><p>说得更简单一点，就是说如果某个非 master 节点宕机了。那么此节点上的 primary shard 不就没了。那好，master 会让 primary shard 对应的 replica shard（在其他机器上）切换为 primary shard。如果宕机的机器修复了，修复后的节点也不再是 primary shard，而是 replica shard。</p><p>其实上述就是 ElasticSearch 作为分布式搜索引擎最基本的一个架构设计。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;es 的分布式架构原理能说一下么（es 是如何实现分布式的啊）？&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;在搜索这块，lucene 是最流行的搜索库。几年前业内一般都问，你了解 lucene 吗？你知道倒排索引的原理吗？现在早已经 out 了，因为现在很多项目都是直接用基于 lucene 的分布式搜索引擎—— ElasticSearch，简称为 es。&lt;/p&gt;
&lt;p&gt;而现在分布式搜索基本已经成为大部分互联网行业的 Java 系统的标配，其中尤为流行的就是 es，前几年 es 没火的时候，大家一般用 solr。但是这两年基本大部分企业和项目都开始转向 es 了。&lt;/p&gt;
&lt;p&gt;所以互联网面试，肯定会跟你聊聊分布式搜索引擎，也就一定会聊聊 es，如果你确实不知道，那你真的就 out 了。&lt;/p&gt;
&lt;p&gt;如果面试官问你第一个问题，确实一般都会问你 es 的分布式架构设计能介绍一下么？就看看你对分布式搜索引擎架构的一个基本理解。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="搜索引擎" scheme="http://shenshanlaoyuan.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个消息队列？</title>
    <link href="http://shenshanlaoyuan.com/2020/05/05/%E9%9D%A2%E8%AF%95/2020-5-5-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/05/05/面试/2020-5-5-如何设计一个消息队列？/</id>
    <published>2020-05-05T03:52:00.000Z</published>
    <updated>2020-05-05T01:27:20.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路。</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>其实聊到这个问题，一般面试官要考察两块：</p><ul><li>你有没有对某一个消息队列做过较为深入的原理的了解，或者从整体了解把握住一个消息队列的架构原理。</li><li>看看你的设计能力，给你一个常见的系统，就是消息队列系统，看看你能不能从全局把握一下整体架构设计，给出一些关键点出来。</li></ul><p>说实话，问类似问题的时候，大部分人基本都会蒙，因为平时从来没有思考过类似的问题，<strong>大多数人就是平时埋头用，从来不去思考背后的一些东西</strong>。类似的问题，比如，如果让你来设计一个 Spring 框架你会怎么做？如果让你来设计一个 Dubbo 框架你会怎么做？如果让你来设计一个 MyBatis 框架你会怎么做？</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/05/05/面试/2020-5-5-如何设计一个消息队列？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/05/05/面试/2020-5-5-如何设计一个消息队列？/'>如何设计一个消息队列？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script> <h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>其实回答这类问题，说白了，不求你看过那技术的源码，起码你要大概知道那个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好。</p><p>比如说这个消息队列系统，我们从以下几个角度来考虑一下：</p><ul><li><p>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</p></li><li><p>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</p></li><li><p>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</p></li><li><p>能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。</p></li></ul><p>mq 肯定是很复杂的，面试官问你这个问题，其实是个开放题，他就是看看你有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;如果让你写一个消息队列，该如何进行架构设计？说一下你的思路。&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;其实聊到这个问题，一般面试官要考察两块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你有没有对某一个消息队列做过较为深入的原理的了解，或者从整体了解把握住一个消息队列的架构原理。&lt;/li&gt;
&lt;li&gt;看看你的设计能力，给你一个常见的系统，就是消息队列系统，看看你能不能从全局把握一下整体架构设计，给出一些关键点出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说实话，问类似问题的时候，大部分人基本都会蒙，因为平时从来没有思考过类似的问题，&lt;strong&gt;大多数人就是平时埋头用，从来不去思考背后的一些东西&lt;/strong&gt;。类似的问题，比如，如果让你来设计一个 Spring 框架你会怎么做？如果让你来设计一个 Dubbo 框架你会怎么做？如果让你来设计一个 MyBatis 框架你会怎么做？&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="消息队列" scheme="http://shenshanlaoyuan.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如何解决消息队列的延时以及过期失效问题？</title>
    <link href="http://shenshanlaoyuan.com/2020/05/04/%E9%9D%A2%E8%AF%95/2020-5-4-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BB%B6%E6%97%B6%E4%BB%A5%E5%8F%8A%E8%BF%87%E6%9C%9F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/05/04/面试/2020-5-4-如何解决消息队列的延时以及过期失效问题？/</id>
    <published>2020-05-04T03:52:00.000Z</published>
    <updated>2020-05-05T01:26:02.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>你看这问法，其实本质针对的场景，都是说，可能你的消费端出了问题，不消费了；或者消费的速度极其慢。接着就坑爹了，可能你的消息队列集群的磁盘都快写满了，都没人消费，这个时候怎么办？或者是这整个就积压了几个小时，你这个时候怎么办？或者是你积压的时间太长了，导致比如 RabbitMQ 设置了消息过期时间后就没了怎么办？</p><p>所以就这事儿，其实线上挺常见的，一般不出，一出就是大 case。一般常见于，举个例子，消费端每次消费之后要写 mysql，结果 mysql 挂了，消费端 hang 那儿了，不动了；或者是消费端出了个什么岔子，导致消费速度极其慢。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/05/04/面试/2020-5-4-如何解决消息队列的延时以及过期失效问题？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/05/04/面试/2020-5-4-如何解决消息队列的延时以及过期失效问题？/'>如何解决消息队列的延时以及过期失效问题？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script> <h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>关于这个事儿，我们一个一个来梳理吧，先假设一个场景，我们现在消费端出故障了，然后大量消息在 mq 里积压，现在出事故了，慌了。</p><h3 id="大量消息在-mq-里积压了几个小时了还没解决"><a href="#大量消息在-mq-里积压了几个小时了还没解决" class="headerlink" title="大量消息在 mq 里积压了几个小时了还没解决"></a>大量消息在 mq 里积压了几个小时了还没解决</h3><p>几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上 11 点多。这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</p><p>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</p><p>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：</p><ul><li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li></ul><h3 id="mq-中的消息过期失效了"><a href="#mq-中的消息过期失效了" class="headerlink" title="mq 中的消息过期失效了"></a>mq 中的消息过期失效了</h3><p>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是<strong>大量的数据会直接搞丢</strong>。</p><p>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是<strong>批量重导</strong>，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</p><p>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p><h3 id="mq-都快写满了"><a href="#mq-都快写满了" class="headerlink" title="mq 都快写满了"></a>mq 都快写满了</h3><p>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，<strong>消费一个丢弃一个，都不要了</strong>，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;你看这问法，其实本质针对的场景，都是说，可能你的消费端出了问题，不消费了；或者消费的速度极其慢。接着就坑爹了，可能你的消息队列集群的磁盘都快写满了，都没人消费，这个时候怎么办？或者是这整个就积压了几个小时，你这个时候怎么办？或者是你积压的时间太长了，导致比如 RabbitMQ 设置了消息过期时间后就没了怎么办？&lt;/p&gt;
&lt;p&gt;所以就这事儿，其实线上挺常见的，一般不出，一出就是大 case。一般常见于，举个例子，消费端每次消费之后要写 mysql，结果 mysql 挂了，消费端 hang 那儿了，不动了；或者是消费端出了个什么岔子，导致消费速度极其慢。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="消息队列" scheme="http://shenshanlaoyuan.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如何保证消息的顺序性？</title>
    <link href="http://shenshanlaoyuan.com/2020/05/03/%E9%9D%A2%E8%AF%95/2020-5-3-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/05/03/面试/2020-5-3-如何保证消息的顺序性？/</id>
    <published>2020-05-03T03:52:00.000Z</published>
    <updated>2020-05-05T01:23:22.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>如何保证消息的顺序性？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>其实这个也是用 MQ 的时候必问的话题，第一看看你了不了解顺序这个事儿？第二看看你有没有办法保证消息是有顺序的？这是生产系统中常见的问题。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/05/03/面试/2020-5-3-如何保证消息的顺序性？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/05/03/面试/2020-5-3-如何保证消息的顺序性？/'>如何保证消息的顺序性？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script> <h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>我举个例子，我们以前做过一个 mysql <code>binlog</code> 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p><p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 <code>binlog</code> 日志，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你愣是换了顺序给执行成删除、修改、增加，不全错了么。</p><p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p><p>先看看顺序会错乱的俩场景：</p><ul><li><strong>RabbitMQ</strong>：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱了。</li></ul><p><img src="https://i.loli.net/2020/04/29/Ptz35FAOmhpbKLo.png" alt="rabbitmq-order-01.png"></p><ul><li><strong>Kafka</strong>：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li></ul><p><img src="https://i.loli.net/2020/04/29/vGMBPbeEmlJF8AX.png" alt="kafka-order-01.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。<br><img src="https://i.loli.net/2020/04/29/QZmI3DhewcgWqRP.png" alt="rabbitmq-order-02.png"></p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><p><img src="https://i.loli.net/2020/04/29/CyVBjEerh8T6RWG.png" alt="kafka-order-02.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;如何保证消息的顺序性？&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;其实这个也是用 MQ 的时候必问的话题，第一看看你了不了解顺序这个事儿？第二看看你有没有办法保证消息是有顺序的？这是生产系统中常见的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="消息队列" scheme="http://shenshanlaoyuan.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如何保证消息的可靠性传输？</title>
    <link href="http://shenshanlaoyuan.com/2020/05/02/%E9%9D%A2%E8%AF%95/2020-5-2-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/05/02/面试/2020-5-2-如何保证消息的可靠性传输？/</id>
    <published>2020-05-02T03:52:00.000Z</published>
    <updated>2020-05-09T02:05:02.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>这个是肯定的，用 MQ 有个基本原则，就是<strong>数据不能多一条，也不能少一条</strong>，不能多，就是前面说的<a href="http://shenshanlaoyuan.com/2020/05/01/面试/2020-5-1-如何保证消息不被重复消费？/">重复消费和幂等性问题</a>。不能少，就是说这数据别搞丢了。那这个问题你必须得考虑一下。</p><p>如果说你这个是用 MQ 来传递非常核心的消息，比如说计费、扣费的一些消息，那必须确保这个 MQ 传递过程中<strong>绝对不会把计费消息给弄丢</strong>。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/05/02/面试/2020-5-2-如何保证消息的可靠性传输？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/05/02/面试/2020-5-2-如何保证消息的可靠性传输？/'>如何保证消息的可靠性传输？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p><img src="https://i.loli.net/2020/04/29/TDqAgEfCtRskpGV.png" alt="rabbitmq-message-lose.png"></p><h4 id="生产者弄丢了数据"><a href="#生产者弄丢了数据" class="headerlink" title="生产者弄丢了数据"></a>生产者弄丢了数据</h4><p>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</p><p>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者<strong>发送数据之前</strong>开启 RabbitMQ 事务<code>channel.txSelect</code>，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务<code>channel.txRollback</code>，然后重试发送消息；如果收到了消息，那么可以提交事务<code>channel.txCommit</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开启事务</span></div><div class="line">channel.txSelect</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 这里发送消息</span></div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    channel.txRollback</div><div class="line"></div><div class="line">    <span class="comment">// 这里再次重发这条消息</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 提交事务</span></div><div class="line">channel.txCommit</div></pre></td></tr></table></figure></p><p>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上<strong>吞吐量会下来，因为太耗性能</strong>。</p><p>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 <code>confirm</code> 模式，在生产者那里设置开启 <code>confirm</code> 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 <code>ack</code> 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 <code>nack</code> 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p><p>事务机制和 <code>confirm</code> 机制最大的不同在于，<strong>事务机制是同步的</strong>，你提交一个事务之后会<strong>阻塞</strong>在那儿，但是 <code>confirm</code> 机制是<strong>异步</strong>的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p><p>所以一般在生产者这块<strong>避免数据丢失</strong>，都是用 <code>confirm</code> 机制的。</p><h4 id="RabbitMQ-弄丢了数据"><a href="#RabbitMQ-弄丢了数据" class="headerlink" title="RabbitMQ 弄丢了数据"></a>RabbitMQ 弄丢了数据</h4><p>就是 RabbitMQ 自己弄丢了数据，这个你必须<strong>开启 RabbitMQ 的持久化</strong>，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，<strong>恢复之后会自动读取之前存储的数据</strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，<strong>可能导致少量数据丢失</strong>，但是这个概率较小。</p><p>设置持久化有<strong>两个步骤</strong>：</p><ul><li>创建 queue 的时候将其设置为持久化<br><br>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li><li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2<br><br>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li></ul><p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p><p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p><p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code>，你也是可以自己重发的。</p><h4 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h4><p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，<strong>刚消费到，还没处理，结果进程挂了</strong>，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p><p>这个时候得用 RabbitMQ 提供的 <code>ack</code> 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 <code>ack</code>，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 <code>ack</code> 一把。这样的话，如果你还没处理完，不就没有 <code>ack</code> 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p><p><img src="https://i.loli.net/2020/04/29/v58Tau3UpytYIXV.png" alt="rabbitmq-message-lose-solution.png"></p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h4 id="消费端弄丢了数据-1"><a href="#消费端弄丢了数据-1" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h4><p>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边<strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p><p>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要<strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是<strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p><p>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p><h4 id="Kafka-弄丢了数据"><a href="#Kafka-弄丢了数据" class="headerlink" title="Kafka 弄丢了数据"></a>Kafka 弄丢了数据</h4><p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p><p>生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</p><p>所以此时一般是要求起码设置如下 4 个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul><p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><h4 id="生产者会不会弄丢数据？"><a href="#生产者会不会弄丢数据？" class="headerlink" title="生产者会不会弄丢数据？"></a>生产者会不会弄丢数据？</h4><p>如果按照上述的思路设置了 <code>acks=all</code>，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;这个是肯定的，用 MQ 有个基本原则，就是&lt;strong&gt;数据不能多一条，也不能少一条&lt;/strong&gt;，不能多，就是前面说的&lt;a href=&quot;http://shenshanlaoyuan.com/2020/05/01/面试/2020-5-1-如何保证消息不被重复消费？/&quot;&gt;重复消费和幂等性问题&lt;/a&gt;。不能少，就是说这数据别搞丢了。那这个问题你必须得考虑一下。&lt;/p&gt;
&lt;p&gt;如果说你这个是用 MQ 来传递非常核心的消息，比如说计费、扣费的一些消息，那必须确保这个 MQ 传递过程中&lt;strong&gt;绝对不会把计费消息给弄丢&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="消息队列" scheme="http://shenshanlaoyuan.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如何保证消息不被重复消费？</title>
    <link href="http://shenshanlaoyuan.com/2020/05/01/%E9%9D%A2%E8%AF%95/2020-5-1-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/05/01/面试/2020-5-1-如何保证消息不被重复消费？/</id>
    <published>2020-05-01T03:52:00.000Z</published>
    <updated>2020-05-05T01:19:01.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>其实这是很常见的一个问题，这俩问题基本可以连起来问。既然是消费消息，那肯定要考虑会不会重复消费？能不能避免重复消费？或者重复消费了也别造成系统异常可以吗？这个是 MQ 领域的基本问题，其实本质上还是问你<strong>使用消息队列如何保证幂等性</strong>，这个是你架构里要考虑的一个问题。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/05/01/面试/2020-5-1-如何保证消息不被重复消费？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/05/01/面试/2020-5-1-如何保证消息不被重复消费？/'>如何保证消息不被重复消费？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script> <h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>回答这个问题，首先你别听到重复消息这个事儿，就一无所知吧，你<strong>先大概说一说可能会有哪些重复消费的问题</strong>。</p><p>首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，正常。因为这问题通常不是 MQ 自己保证的，是由我们开发来保证的。挑一个 Kafka 来举个例子，说说怎么重复消费吧。</p><p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，<strong>每隔一段时间</strong>（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p><p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p><p>举个栗子。</p><p>有这么个场景。数据 1/2/3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152/153/154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 <code>offset=153</code> 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1/2 的 offset 并没有提交，kafka 也就不知道你已经消费了 <code>offset=153</code> 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1/2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p><p><img src="https://i.loli.net/2020/04/29/iDP3fFa4jMNOSVv.png" alt="mq-10.png"></p><p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1/2 在数据库里插入了 2 次，那么数据就错啦。</p><p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，<strong>怎么保证幂等性</strong>。</p><p>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p><p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p><p>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，<strong>不能出错</strong>。</p><p>所以第二个问题来了，怎么保证消息队列消费的幂等性？</p><p>其实还是得结合业务来思考，我这里给几个思路：</p><ul><li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li><li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li><li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li><li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li></ul><p><img src="https://i.loli.net/2020/04/29/VPBAgM9I3NWm52O.png" alt="mq-11.png"></p><p>当然，如何保证 MQ 的消费是幂等性的，需要结合具体的业务来看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;其实这是很常见的一个问题，这俩问题基本可以连起来问。既然是消费消息，那肯定要考虑会不会重复消费？能不能避免重复消费？或者重复消费了也别造成系统异常可以吗？这个是 MQ 领域的基本问题，其实本质上还是问你&lt;strong&gt;使用消息队列如何保证幂等性&lt;/strong&gt;，这个是你架构里要考虑的一个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="消息队列" scheme="http://shenshanlaoyuan.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如何保证消息队列的高可用？</title>
    <link href="http://shenshanlaoyuan.com/2020/04/30/%E9%9D%A2%E8%AF%95/2020-4-30-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/04/30/面试/2020-4-30-如何保证消息队列的高可用？/</id>
    <published>2020-04-30T03:52:00.000Z</published>
    <updated>2020-05-09T02:03:49.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>如何保证消息队列的高可用？</p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>如果有人问到你 MQ 的知识，<strong>高可用是必问的</strong>。<a href="http://shenshanlaoyuan.com/2020/04/29/面试/2020-4-29-为什么使用消息队列？/">上一讲</a>提到，MQ 会导致<strong>系统可用性降低</strong>。所以只要你用了 MQ，接下来问的一些要点肯定就是围绕着 MQ 的那些缺点怎么来解决了。</p><p>要是你傻乎乎的就干用了一个 MQ，各种问题从来没考虑过，那你就杯具了，面试官对你的感觉就是，只会简单使用一些技术，没任何思考，马上对你的印象就不太好了。这样的同学招进来要是做个 20k 薪资以内的普通小弟还凑合，要是做薪资 20k+ 的高工，那就惨了，让你设计个系统，里面肯定一堆坑，出了事故公司受损失，团队一起背锅。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/04/30/面试/2020-4-30-如何保证消息队列的高可用？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/04/30/面试/2020-4-30-如何保证消息队列的高可用？/'>如何保证消息队列的高可用？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script> <h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>这个问题这么问是很好的，因为不能问你 Kafka 的高可用性怎么保证？ActiveMQ 的高可用性怎么保证？一个面试官要是这么问就显得很没水平，人家可能用的就是 RabbitMQ，没用过 Kafka，你上来问人家 Kafka 干什么？这不是摆明了刁难人么。</p><p>所以有水平的面试官，问的是 MQ 的高可用性怎么保证？这样就是你用过哪个 MQ，你就说说你对那个 MQ 的高可用性的理解。</p><h3 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h3><p>RabbitMQ 是比较有代表性的，因为是<strong>基于主从</strong>（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。</p><p>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p><h4 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h4><p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的😄，没人生产用单机模式。</p><h4 id="普通集群模式（无高可用性）"><a href="#普通集群模式（无高可用性）" class="headerlink" title="普通集群模式（无高可用性）"></a>普通集群模式（无高可用性）</h4><p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你<strong>创建的 queue，只会放在一个 RabbitMQ 实例上</strong>，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</p><p><img src="https://i.loli.net/2020/04/29/bzt2Bgy1OJQfxW8.png" alt="mq-7.png"></p><p>这种方式确实很麻烦，也不怎么好，<strong>没做到所谓的分布式</strong>，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有<strong>数据拉取的开销</strong>，后者导致<strong>单实例性能瓶颈</strong>。</p><p>而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你<strong>开启了消息持久化</strong>，让 RabbitMQ 落地存储消息的话，<strong>消息不一定会丢</strong>，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。</p><p>所以这个事儿就比较尴尬了，这就<strong>没有什么所谓的高可用性</strong>，<strong>这方案主要是提高吞吐量的</strong>，就是说让集群中多个节点来服务某个 queue 的读写操作。</p><h4 id="镜像集群模式（高可用性）"><a href="#镜像集群模式（高可用性）" class="headerlink" title="镜像集群模式（高可用性）"></a>镜像集群模式（高可用性）</h4><p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会<strong>存在于多个实例上</strong>，就是说，每个 RabbitMQ 节点都有这个 queue 的一个<strong>完整镜像</strong>，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把<strong>消息同步</strong>到多个实例的 queue 上。</p><p><img src="https://i.loli.net/2020/04/29/dfqoF17r5nPWle9.png" alt="mq-8.png"></p><p>那么<strong>如何开启这个镜像集群模式</strong>呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是<strong>镜像集群模式的策略</strong>，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p><p>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就<strong>没有扩展性可言</strong>了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并<strong>没有办法线性扩展</strong>你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</p><h3 id="Kafka-的高可用性"><a href="#Kafka-的高可用性" class="headerlink" title="Kafka 的高可用性"></a>Kafka 的高可用性</h3><p>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p><p>这就是<strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是<strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p><p>实际上 RabbitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p><p>Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。</p><p>比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1/3 的数据就丢了，因此这个是做不到高可用的。</p><p><img src="https://i.loli.net/2020/04/29/I7RbKUCLoPaDf84.png" alt="kafka-before.png"></p><p>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。只能读写 leader？很简单，<strong>要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题</strong>，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p><p><img src="https://i.loli.net/2020/04/29/D36HiSJEpqxCIF5.png" alt="kafka-after.png"></p><p>这么搞，就有所谓的<strong>高可用性</strong>了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中<strong>重新选举</strong>一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p><p><strong>写数据</strong>的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p><p><strong>消费</strong>的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><p>看到这里，相信你大致明白了 Kafka 是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要是遇上面试官确实是 Kafka 高手，深挖了问，那你只能说不好意思，太深入的你没研究过。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;如何保证消息队列的高可用？&lt;/p&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;如果有人问到你 MQ 的知识，&lt;strong&gt;高可用是必问的&lt;/strong&gt;。&lt;a href=&quot;http://shenshanlaoyuan.com/2020/04/29/面试/2020-4-29-为什么使用消息队列？/&quot;&gt;上一讲&lt;/a&gt;提到，MQ 会导致&lt;strong&gt;系统可用性降低&lt;/strong&gt;。所以只要你用了 MQ，接下来问的一些要点肯定就是围绕着 MQ 的那些缺点怎么来解决了。&lt;/p&gt;
&lt;p&gt;要是你傻乎乎的就干用了一个 MQ，各种问题从来没考虑过，那你就杯具了，面试官对你的感觉就是，只会简单使用一些技术，没任何思考，马上对你的印象就不太好了。这样的同学招进来要是做个 20k 薪资以内的普通小弟还凑合，要是做薪资 20k+ 的高工，那就惨了，让你设计个系统，里面肯定一堆坑，出了事故公司受损失，团队一起背锅。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="消息队列" scheme="http://shenshanlaoyuan.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>为什么使用消息队列？</title>
    <link href="http://shenshanlaoyuan.com/2020/04/29/%E9%9D%A2%E8%AF%95/2020-4-29-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/04/29/面试/2020-4-29-为什么使用消息队列？/</id>
    <published>2020-04-29T03:52:00.000Z</published>
    <updated>2020-05-09T01:58:46.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>为什么使用消息队列？</li><li>消息队列有什么优点和缺点？</li><li>Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别，以及适合哪些场景？</li></ul><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>其实面试官主要是想看看：</p><ul><li><strong>第一</strong>，你知不知道你们系统里为什么要用消息队列这个东西？</li></ul><p>不少候选人，说自己项目里用了 Redis、MQ，但是其实他并不知道自己为什么要用这个东西。其实说白了，就是为了用而用，或者是别人设计的架构，他从头到尾都没思考过。</p><p>没有对自己的架构问过为什么的人，一定是平时没有思考的人，面试官对这类候选人印象通常很不好。因为面试官担心你进了团队之后只会木头木脑的干呆活儿，不会自己思考。</p><ul><li><strong>第二</strong>，你既然用了消息队列这个东西，你知不知道用了有什么好处&amp;坏处？</li></ul><p>你要是没考虑过这个，那你盲目弄个 MQ 进系统里，后面出了问题你是不是就自己溜了给公司留坑？你要是没考虑过引入一个技术可能存在的弊端和风险，面试官把这类候选人招进来了，基本可能就是挖坑型选手。就怕你干 1 年挖一堆坑，自己跳槽了，给公司留下无穷后患。</p><ul><li><strong>第三</strong>，既然你用了 MQ，可能是某一种 MQ，那么你当时做没做过调研？</li></ul><p>你别傻乎乎的自己拍脑袋看个人喜好就瞎用了一个 MQ，比如 Kafka，甚至都从没调研过业界流行的 MQ 到底有哪几种。每一个 MQ 的优点和缺点是什么。每一个 MQ <strong>没有绝对的好坏</strong>，但是就是看用在哪个场景可以<strong>扬长避短，利用其优势，规避其劣势</strong>。</p><p>如果是一个不考虑技术选型的候选人招进了团队，leader 交给他一个任务，去设计个什么系统，他在里面用一些技术，可能都没考虑过选型，最后选的技术可能并不一定合适，一样是留坑。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/04/29/面试/2020-4-29-为什么使用消息队列？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/04/29/面试/2020-4-29-为什么使用消息队列？/'>为什么使用消息队列？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><h3 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h3><p>其实就是问问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景里用消息队列是什么？</p><p>面试官问你这个问题，<strong>期望的一个回答</strong>是说，你们公司有个什么<strong>业务场景</strong>，这个业务场景有个什么技术挑战，如果不用 MQ 可能会很麻烦，但是你现在用了 MQ 之后带给了你很多的好处。</p><p>先说一下消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</p><p><img src="https://i.loli.net/2020/04/29/W18fTLxVDkwgrFp.png" alt="mq-1.png"></p><p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p><p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p><img src="https://i.loli.net/2020/04/29/dPD5ROkJF8mW6vf.png" alt="mq-2.png"></p><p><strong>总结</strong>：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p><p><strong>面试技巧</strong>：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p><p><img src="https://i.loli.net/2020/04/29/qMkf8DshPvQH1Ar.png" alt="mq-3.png"></p><p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p><p>如果<strong>使用 MQ</strong>，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p><p><img src="https://i.loli.net/2020/04/29/eLV5IEqmkiNv7fK.png" alt="mq-4.png"></p><h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p><p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p><p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p><p><img src="https://i.loli.net/2020/04/29/oBrGk1bnc7Sp5mN.png" alt="mq-5.png"></p><p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p><p><img src="https://i.loli.net/2020/04/29/TGJFC5QgauDPsqd.png" alt="mq-6.png"></p><p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p><h3 id="消息队列有什么优缺点"><a href="#消息队列有什么优缺点" class="headerlink" title="消息队列有什么优缺点"></a>消息队列有什么优缺点</h3><p>优点上面已经说了，就是<strong>在特殊场景下有其对应的好处</strong>，<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p><p>缺点有以下几个：</p><ul><li>系统可用性降低</li></ul><p>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，ABCD 四个系统还好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整？MQ 一挂，整套系统崩溃，你不就完了？如何保证消息队列的高可用，可以<a href="http://shenshanlaoyuan.com/2020/04/30/面试/2020-4-30-如何保证消息队列的高可用？/">点击这里查看</a>。</p><ul><li>系统复杂度提高</li></ul><p>硬生生加个 MQ 进来，你怎么<a href="http://shenshanlaoyuan.com/2020/05/01/面试/2020-5-1-如何保证消息不被重复消费？/">保证消息没有重复消费</a>？怎么<a href="http://shenshanlaoyuan.com/2020/05/02/面试/2020-5-2-如何保证消息的可靠性传输？/">处理消息丢失的情况</a>？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</p><ul><li>一致性问题</li></ul><p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p><p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p><h3 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>综上，各种对比之后，有如下建议：</p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq" target="_blank" rel="external">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为什么使用消息队列？&lt;/li&gt;
&lt;li&gt;消息队列有什么优点和缺点？&lt;/li&gt;
&lt;li&gt;Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别，以及适合哪些场景？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;面试官心理分析&lt;/h2&gt;&lt;p&gt;其实面试官主要是想看看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一&lt;/strong&gt;，你知不知道你们系统里为什么要用消息队列这个东西？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不少候选人，说自己项目里用了 Redis、MQ，但是其实他并不知道自己为什么要用这个东西。其实说白了，就是为了用而用，或者是别人设计的架构，他从头到尾都没思考过。&lt;/p&gt;
&lt;p&gt;没有对自己的架构问过为什么的人，一定是平时没有思考的人，面试官对这类候选人印象通常很不好。因为面试官担心你进了团队之后只会木头木脑的干呆活儿，不会自己思考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第二&lt;/strong&gt;，你既然用了消息队列这个东西，你知不知道用了有什么好处&amp;amp;坏处？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你要是没考虑过这个，那你盲目弄个 MQ 进系统里，后面出了问题你是不是就自己溜了给公司留坑？你要是没考虑过引入一个技术可能存在的弊端和风险，面试官把这类候选人招进来了，基本可能就是挖坑型选手。就怕你干 1 年挖一堆坑，自己跳槽了，给公司留下无穷后患。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第三&lt;/strong&gt;，既然你用了 MQ，可能是某一种 MQ，那么你当时做没做过调研？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你别傻乎乎的自己拍脑袋看个人喜好就瞎用了一个 MQ，比如 Kafka，甚至都从没调研过业界流行的 MQ 到底有哪几种。每一个 MQ 的优点和缺点是什么。每一个 MQ &lt;strong&gt;没有绝对的好坏&lt;/strong&gt;，但是就是看用在哪个场景可以&lt;strong&gt;扬长避短，利用其优势，规避其劣势&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果是一个不考虑技术选型的候选人招进了团队，leader 交给他一个任务，去设计个什么系统，他在里面用一些技术，可能都没考虑过选型，最后选的技术可能并不一定合适，一样是留坑。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="消息队列" scheme="http://shenshanlaoyuan.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试遇到连环炮该如何接招？</title>
    <link href="http://shenshanlaoyuan.com/2020/04/28/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%81%87%E5%88%B0%E8%BF%9E%E7%8E%AF%E7%82%AE%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%A5%E6%8B%9B%EF%BC%9F/"/>
    <id>http://shenshanlaoyuan.com/2020/04/28/面试/面试遇到连环炮该如何接招？/</id>
    <published>2020-04-28T03:52:00.000Z</published>
    <updated>2020-04-28T03:34:06.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息队列面试场景"><a href="#消息队列面试场景" class="headerlink" title="消息队列面试场景"></a>消息队列面试场景</h2><p><strong>面试官</strong>：你好。</p><p><strong>候选人</strong>：你好。</p><p>（面试官在你的简历上面看到了，呦，有个亮点，你在项目里用过 <code>MQ</code>，比如说你用过 <code>ActiveMQ</code>）</p><p><strong>面试官</strong>：你在系统里用过消息队列吗？（面试官在随和的语气中展开了面试）</p><p><strong>候选人</strong>：用过的（此时感觉没啥）</p><p><strong>面试官</strong>：那你说一下你们在项目里是怎么用消息队列的？</p><p><strong>候选人</strong>：巴拉巴拉，“我们啥啥系统发送个啥啥消息到队列，别的系统来消费啥啥的。比如我们有个订单系统，订单系统每次下一个新的订单的时候，就会发送一条消息到 <code>ActiveMQ</code> 里面去，后台有个库存系统负责获取消息然后更新库存。”</p><p>（部分同学在这里会进入一个误区，就是你仅仅就是知道以及回答你们是怎么用这个消息队列的，用这个消息队列来干了个什么事情？）</p><p><strong>面试官</strong>：那你们为什么使用消息队列啊？你的订单系统不发送消息到 <code>MQ</code>，直接订单系统调用库存系统一个接口，咔嚓一下，直接就调用成功，库存不也就更新了。</p><p><strong>候选人</strong>：额。。。（楞了一下，为什么？我没怎么仔细想过啊，老大让用就用了），硬着头皮胡言乱语了几句。</p><p>（面试官此时听你楞了一下，然后听你胡言乱语了几句，开始心里觉得有点儿那什么了，怀疑你之前就压根儿没思考过这问题）</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2020/04/28/面试/面试遇到连环炮该如何接招？/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2020/04/28/面试/面试遇到连环炮该如何接招？/'>面试遇到连环炮该如何接招？</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script> <p><strong>面试官</strong>：那你说说用消息队列都有什么优点和缺点？</p><p>（面试官此时心里想的是，你的 <code>MQ</code> 在项目里为啥要用，你没怎么考虑过，那我稍微简单点儿，我问问你消息队列你之前有没有考虑过如果用的话，优点和缺点分别是啥？）</p><p><strong>候选人</strong>：这个。。。（确实平时没怎么考虑过这个问题啊。。。胡言乱语了）</p><p>（面试官此时心里已经更觉得你这哥儿们不行，平时都没什么思考）</p><p><strong>面试官</strong>：<code>Kafka</code>、<code>ActiveMQ</code>、<code>RabbitMQ</code>、<code>RocketMQ</code> 都有什么区别？</p><p>（面试官问你这个问题，就是说，绕过比较虚的话题，直接看看你对各种 <code>MQ</code> 中间件是否了解，是否做过功课，是否做过调研）</p><p><strong>候选人</strong>：我们就用过 <code>ActiveMQ</code>，所以别的没用过。。。区别，也不太清楚。。。</p><p>（面试官此时更是觉得你这哥儿们平时就是瞎用，根本就没什么思考，觉得不行）</p><p><strong>面试官</strong>：那你们是如何保证消息队列的高可用啊？</p><p><strong>候选人</strong>：这个。。。我平时就是简单走 API 调用一下，不太清楚消息队列怎么部署的。。。</p><p><strong>面试官</strong>：如何保证消息不被重复消费啊？如何保证消费的时候是幂等的啊？</p><p><strong>候选人</strong>：啥？（<code>MQ</code> 不就是写入&amp;消费就可以了，哪来这么多问题）</p><p><strong>面试官</strong>：如何保证消息的可靠性传输啊？要是消息丢失了怎么办啊？</p><p><strong>候选人</strong>：我们没怎么丢过消息啊。。。</p><p><strong>面试官</strong>：那如何保证消息的顺序性？</p><p><strong>候选人</strong>：顺序性？什么意思？我为什么要保证消息的顺序性？它不是本来就有顺序吗？</p><p><strong>面试官</strong>：如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</p><p><strong>候选人</strong>：不是，我这平时没遇到过这些问题啊，就是简单用用，知道 <code>MQ</code> 的一些功能。</p><p><strong>面试官</strong>：如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路。</p><p><strong>候选人</strong>：。。。。。我还是走吧。。。。</p><hr><p>这其实是面试官的一种面试风格，就是说面试官的问题不是发散的，而是从一个小点慢慢铺开。比如说面试官可能会跟你聊聊高并发话题，就这个话题里面跟你聊聊缓存、<code>MQ</code> 等等东西，<strong>由浅入深，一步步深挖</strong>。</p><p>其实上面是一个非常典型的关于消息队列的技术考察过程，好的面试官一定是从你做过的某一个点切入，然后层层展开深入考察，一个接一个问，直到把这个技术点刨根问底，问到最底层。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;消息队列面试场景&quot;&gt;&lt;a href=&quot;#消息队列面试场景&quot; class=&quot;headerlink&quot; title=&quot;消息队列面试场景&quot;&gt;&lt;/a&gt;消息队列面试场景&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;面试官&lt;/strong&gt;：你好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;候选人&lt;/strong&gt;：你好。&lt;/p&gt;
&lt;p&gt;（面试官在你的简历上面看到了，呦，有个亮点，你在项目里用过 &lt;code&gt;MQ&lt;/code&gt;，比如说你用过 &lt;code&gt;ActiveMQ&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官&lt;/strong&gt;：你在系统里用过消息队列吗？（面试官在随和的语气中展开了面试）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;候选人&lt;/strong&gt;：用过的（此时感觉没啥）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官&lt;/strong&gt;：那你说一下你们在项目里是怎么用消息队列的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;候选人&lt;/strong&gt;：巴拉巴拉，“我们啥啥系统发送个啥啥消息到队列，别的系统来消费啥啥的。比如我们有个订单系统，订单系统每次下一个新的订单的时候，就会发送一条消息到 &lt;code&gt;ActiveMQ&lt;/code&gt; 里面去，后台有个库存系统负责获取消息然后更新库存。”&lt;/p&gt;
&lt;p&gt;（部分同学在这里会进入一个误区，就是你仅仅就是知道以及回答你们是怎么用这个消息队列的，用这个消息队列来干了个什么事情？）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官&lt;/strong&gt;：那你们为什么使用消息队列啊？你的订单系统不发送消息到 &lt;code&gt;MQ&lt;/code&gt;，直接订单系统调用库存系统一个接口，咔嚓一下，直接就调用成功，库存不也就更新了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;候选人&lt;/strong&gt;：额。。。（楞了一下，为什么？我没怎么仔细想过啊，老大让用就用了），硬着头皮胡言乱语了几句。&lt;/p&gt;
&lt;p&gt;（面试官此时听你楞了一下，然后听你胡言乱语了几句，开始心里觉得有点儿那什么了，怀疑你之前就压根儿没思考过这问题）&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenshanlaoyuan.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="消息队列" scheme="http://shenshanlaoyuan.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>慕课网高并发课程笔记（三）-项目准备</title>
    <link href="http://shenshanlaoyuan.com/2018/05/05/Java/bingfa3/"/>
    <id>http://shenshanlaoyuan.com/2018/05/05/Java/bingfa3/</id>
    <published>2018-05-05T13:50:00.000Z</published>
    <updated>2018-09-05T16:13:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全与线程不安全"><a href="#线程安全与线程不安全" class="headerlink" title="线程安全与线程不安全"></a>线程安全与线程不安全</h2><ul><li>线程安全：代码所在的进程有多个线程在同时运行，这些线程可能会同时运行同一段代码，如果每次运行的结果和单线程运行的结果一样的，而且其他的变量的值也和预期是一样的，我们就认为这是线程安全的。简单的说，就是并发环境下得到我们期望的结果。</li><li>线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据，所得到的数据是脏数据，也可能是在计算中出现错误。</li></ul><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2018/05/05/Java/bingfa3/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2018/05/05/Java/bingfa3/'>慕课网高并发课程笔记（三）-项目准备</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script><h2 id="环境搭建与准备"><a href="#环境搭建与准备" class="headerlink" title="环境搭建与准备"></a>环境搭建与准备</h2><h3 id="Spring-Boot构建项目"><a href="#Spring-Boot构建项目" class="headerlink" title="Spring Boot构建项目"></a>Spring Boot构建项目</h3><p><a href="Https://start.spring.io/" target="_blank" rel="external">Https://start.spring.io/</a></p><p>具体搭建过程参考视频。</p><h3 id="注解的准备"><a href="#注解的准备" class="headerlink" title="注解的准备"></a>注解的准备</h3><ul><li><p>线程安全的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 对于线程安全的类，加入一个<span class="doctag">@ThreadSafe</span>注解的标示</div><div class="line"> * <span class="doctag">@Target</span>(ElementType.TYPE) 说明作用于类上</div><div class="line"> * <span class="doctag">@Retention</span>(RetentionPolicy.SOURCE) 指定注解作用的范围，在编译的时候就会被忽略掉</div><div class="line"> * <span class="doctag">@author</span> gaowenfeng</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ThreadSafe &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>线程不安全的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用来标示[线程不安全的类]</div><div class="line"> * <span class="doctag">@Target</span>(ElementType.TYPE) 说明作用于类上</div><div class="line"> * <span class="doctag">@Retention</span>(RetentionPolicy.SOURCE) 指定注解作用的范围，在编译的时候就会被忽略掉</div><div class="line"> * <span class="doctag">@author</span> gaowenfeng</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotThreadSafe &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>推荐写法的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用来标记[推荐]的类或者写法</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Recommend &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>不推荐写法的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用来标记[不推荐]的类或者写法</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotRecommend &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h4 id="ElementType-详解"><a href="#ElementType-详解" class="headerlink" title="ElementType 详解"></a>ElementType 详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</div><div class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></div><div class="line">   <span class="comment">/** 声明注解作用在类，借口，枚举上*/</span></div><div class="line">    TYPE,</div><div class="line"></div><div class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></div><div class="line">   <span class="comment">/** 声明注解作用在属性上*/</span></div><div class="line">    FIELD,</div><div class="line"></div><div class="line">    <span class="comment">/** Method declaration */</span></div><div class="line">   <span class="comment">/** 声明注解作用在方法上*/</span></div><div class="line">    METHOD,</div><div class="line"></div><div class="line">    <span class="comment">/** Formal parameter declaration */</span></div><div class="line">   <span class="comment">/** 声明注解作用在参数上*/</span></div><div class="line">    PARAMETER,</div><div class="line"></div><div class="line">    <span class="comment">/** Constructor declaration */</span></div><div class="line">   <span class="comment">/** 声明注解作用在构造函数上*/</span></div><div class="line">    CONSTRUCTOR,</div><div class="line"></div><div class="line">    <span class="comment">/** Local variable declaration */</span></div><div class="line">   <span class="comment">/** 声明注解作用在本地变量上*/</span></div><div class="line">    LOCAL_VARIABLE,</div><div class="line"></div><div class="line">    <span class="comment">/** Annotation type declaration */</span></div><div class="line">   <span class="comment">/** 声明注解作用在注解上*/</span></div><div class="line">    ANNOTATION_TYPE,</div><div class="line"></div><div class="line">    <span class="comment">/** Package declaration */</span></div><div class="line">   <span class="comment">/** 声明注解作用在包上*/</span></div><div class="line">    PACKAGE,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Type parameter declaration</div><div class="line">     *</div><div class="line">     * <span class="doctag">@since</span> 1.8</div><div class="line">     */</div><div class="line">   <span class="comment">/** 声明注解可以应用在TYPE声明上*/</span></div><div class="line">    TYPE_PARAMETER,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Use of a type</div><div class="line">     * Type.TYPE_USE 表示这个 Annotation 可以用在所有使用 Type 的地方（如：泛型，类型转换等）</div><div class="line">     * <span class="doctag">@since</span> 1.8</div><div class="line">     */</div><div class="line">    TYPE_USE</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="RetentionPolicy详解"><a href="#RetentionPolicy详解" class="headerlink" title="RetentionPolicy详解"></a>RetentionPolicy详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Annotations are to be discarded by the compiler.</div><div class="line">     * 在编译的时候会被取消，只用于声明，理解，或者测试</div><div class="line">     */</div><div class="line">    SOURCE,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Annotations are to be recorded in the class file by the compiler</div><div class="line">     * but need not be retained by the VM at run time.  This is the default</div><div class="line">     * behavior.</div><div class="line">     * 注解将被编译器记录在类文件中，但在运行时不需要由VM保留，（默认的选项）</div><div class="line">     */</div><div class="line">    CLASS,</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Annotations are to be recorded in the class file by the compiler and</div><div class="line">     * retained by the VM at run time, so they may be read reflectively.</div><div class="line">     * 注解将被编译器记录在类文件中，但在运行时由VM保留，这样他们可以被反射获取（当你需要获取注解中字段的属性值的时候，需要用这个，比如AOP）</div><div class="line">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</div><div class="line">     */</div><div class="line">    RUNTIME</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="并发模拟工具"><a href="#并发模拟工具" class="headerlink" title="并发模拟工具"></a>并发模拟工具</h2><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180621152956285679441.png" alt="工具"></p><h2 id="并发模拟代码"><a href="#并发模拟代码" class="headerlink" title="并发模拟代码"></a>并发模拟代码</h2><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180621152956311599230.png" alt=""></p><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180621152956319836166.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程安全与线程不安全&quot;&gt;&lt;a href=&quot;#线程安全与线程不安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全与线程不安全&quot;&gt;&lt;/a&gt;线程安全与线程不安全&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;线程安全：代码所在的进程有多个线程在同时运行，这些线程可能会同时运行同一段代码，如果每次运行的结果和单线程运行的结果一样的，而且其他的变量的值也和预期是一样的，我们就认为这是线程安全的。简单的说，就是并发环境下得到我们期望的结果。&lt;/li&gt;
&lt;li&gt;线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据，所得到的数据是脏数据，也可能是在计算中出现错误。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://shenshanlaoyuan.com/categories/Java/"/>
    
    
      <category term="高并发" scheme="http://shenshanlaoyuan.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>慕课网高并发课程笔记（二）-并发基础</title>
    <link href="http://shenshanlaoyuan.com/2018/05/04/Java/bingfa2/"/>
    <id>http://shenshanlaoyuan.com/2018/05/04/Java/bingfa2/</id>
    <published>2018-05-04T13:50:00.000Z</published>
    <updated>2018-08-27T07:06:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h2><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180531152774962796143.png" alt="CPU多级缓存"></p><p>图左侧为最简单的高速缓存的配置，数据的读取和存储都经过高速缓存，CPU核心与高速缓存有一条特殊的快速通道；主存与高速缓存都连在系统总线上（BUS）这条总线还用于其他组件的通信。</p><p>在高速缓存出现后不久，系统变得越来越复杂，高速缓存与主存之间的速度差异被拉大，直到加入了另一级缓存，新加入的这级缓存比第一缓存更大，并且更慢，由于加大一级缓存从经济上考虑是行不通的，所以有了二级缓存，甚至是三级缓存。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2018/05/04/Java/bingfa2/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2018/05/04/Java/bingfa2/'>慕课网高并发课程笔记（二）-并发基础</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script><h3 id="为什么需要CPU缓存？"><a href="#为什么需要CPU缓存？" class="headerlink" title="为什么需要CPU缓存？"></a>为什么需要CPU缓存？</h3><p>CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu-&gt;cache-&gt;memort）。</p><h3 id="CPU缓存有什么意义？"><a href="#CPU缓存有什么意义？" class="headerlink" title="CPU缓存有什么意义？"></a>CPU缓存有什么意义？</h3><ol><li>时间局部性：如果某个数据被访问，那么在不久的将来他很可能被再次访问</li><li>空间局部性：如果某个数据被访问，那么与他相邻的数据很快也可能被访问</li></ol><h2 id="CPU多级缓存-缓存一致性（MESI）"><a href="#CPU多级缓存-缓存一致性（MESI）" class="headerlink" title="CPU多级缓存-缓存一致性（MESI）"></a>CPU多级缓存-缓存一致性（MESI）</h2><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180531152775055531383.png" alt="缓存一致性"></p><ul><li><strong>M: Modified 修改</strong>，指的是该缓存行只被缓存在该CPU的缓存中，并且是被修改过的，因此他与主存中的数据是不一致的，该缓存行中的数据需要在未来的某个时间点（允许其他CPU读取主存相应中的内容之前）写回主存，然后状态变成E（独享）</li><li><p><strong>E：Exclusive 独享</strong> ，缓存行只被缓存在该CPU的缓存中，是未被修改过的，与主存的数据是一致的，可以在任何时刻当有其他CPU读取该内存时，变成S（共享）状态，当CPU修改该缓存行的内容时，变成M（被修改）的状态</p></li><li><p><strong>S：Share 共享</strong>，意味着该缓存行可能会被多个CPU进行缓存，并且该缓存中的数据与主存数据是一致的，当有一个CPU修改该缓存行时，其他CPU是可以被作废的，变成I(无效的)</p></li><li><strong>I：Invalid 无效的</strong>，代表这个缓存是无效的，可能是有其他CPU修改了该缓存行</li></ul><p>用于保证多个CPU cache之间缓存共享数据的一致</p><ul><li>local read：读本地缓存的数据</li><li>local write：将数据写到本地缓存里面</li><li>remote read：将内（主）存中的数据读取到缓存中来</li><li>remote write：将缓存中的数据写会到主存里面</li></ul><p>在一个典型的多核系统中，每一个核都会有自己的缓存来共享主存总线，每一个CPU会发出读写（I/O）请求，而缓存的目的是为了减少CPU读写共享主存的次数；<br>一个缓存除了在Invaild状态，都可以满足CPU 的读请求</p><p>一个写请求只有在M状态，或者E状态的时候才能给被执行，如果是处在S状态的时候，他必须先将该缓存行变成I状态，<br>这个操作通常作用于广播的方式来完成，这个时候他既不允许不同的CPU同时修改同一个缓存行，即使是修改同一个缓存行中不同端的数据也是不可以的，这里主要解决的是缓存一致性的问题，<br>一个M状态的缓存行必须时刻监听所有试图读该缓存行相对主存的操作，这种操作必须在缓存该缓存行被写会到主存，并将状态变成S状态之前，被延迟执行</p><p>一个处于S状态的缓存行，也必须监听其他缓存使该缓存行无效，或者独享该缓存行的请求，并将缓存行变成无效</p><p>一个处于E状态的缓存行，他要监听其他缓存读缓存行的操作，一旦有，那么他讲变成S状态</p><p>因此对于M和E状态，他们的数据总是一致的与缓存行的真正状态总是保持一致的，<br>但是S状态可能是非一致的，如果一个缓存将处于S状态的 缓存行作废了，另一个缓存可能已经独享了该缓存行，<br>但是该缓存缺不会讲该缓存行升迁为E状态，这是因为其他缓存不会广播他们已经作废掉该缓存行的通知，<br>同样由于缓存并没有保存该缓存行被COPY的数量，因此没有办法确定是否独享了改缓存行，<br>这是一种投机性的优化，因为如果一个CPU想修改一个处于S状态的缓存行，总线需要将所有使用该缓存行的COPY的值变成Invaild状态才可以，而修改E状态的缓存 却不需要这样做</p><h2 id="CPU多级缓存-乱序执行优化"><a href="#CPU多级缓存-乱序执行优化" class="headerlink" title="CPU多级缓存-乱序执行优化"></a>CPU多级缓存-乱序执行优化</h2><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/2018053115277513621658.png" alt="乱序执行优化"></p><p>处理器多核和缓存导致的一个问题，如果我们不做任何处理，在多核的情况下，的实际结果可能和逻辑运行结果大不相同，如果在一个核上执行数据写入操作，并在最后执行一个操作来标记数据已经写入好了，而在另外一个核上通过该标记位判定数据是否已经写入，这时候就可能出现不一致，标记位先被写入，但是实际的操作缺并未完成，这个未完成既有可能是没有计算完成，也有可能是缓存没有被及时刷新到主存之中，使得其他核读到了错误的数据</p><h2 id="Java内存模型（Java-Memory-Model，JMM）"><a href="#Java内存模型（Java-Memory-Model，JMM）" class="headerlink" title="Java内存模型（Java Memory Model，JMM）"></a>Java内存模型（Java Memory Model，JMM）</h2><h3 id="JAVA内存模型规范"><a href="#JAVA内存模型规范" class="headerlink" title="JAVA内存模型规范"></a>JAVA内存模型规范</h3><p>规定了一个线程如何和何时可以看到其他线程修改过后的共享变量的值 以及何时同步的访问共享变量。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180531152775218881565.png" alt="Java内存模型"></p><ul><li><p>Heap(堆)：java里的堆是一个运行时的数据区，堆是由垃圾回收来负责的，堆的优势是可以动态的分配内存大小，生存期也不必事先告诉编译器，因为他是在运行时动态分配内存的，java的垃圾回收器会定时收走不用的数据， 缺点是由于要在运行时动态分配，所有存取速度可能会慢一些</p></li><li><p>Stack(栈)：栈的优势是存取速度比堆要快，仅次于计算机里的寄存器，栈的数据是可以共享的，缺点是存在栈中的数据的大小与生存期必须是确定的，缺乏一些灵活性。栈中主要存放一些基本类型的变量，比如int，short，long，byte，double，float，boolean，char，对象句柄，</p></li></ul><p>java内存模型要求调用栈和本地内存变量存放在线程栈（Thread Stack）上，对象存放在堆上。<br>一个本地变量可能存放一个对象的引用，这时引用变量存放在本地栈上，但是对象本身存放在堆上</p><p>成员变量跟随着对象存放在堆上，而不管是原始类型还是引用类型，静态成员变量跟随着类的定义一起存在在堆上</p><p>存在堆上的对象，可以被持有这个对象的引用的线程访问</p><p>如果两个线程同时访问同一个对象的私有变量，这时他们获得的是这个对象的私有拷贝</p><h3 id="计算机硬件架构"><a href="#计算机硬件架构" class="headerlink" title="计算机硬件架构"></a>计算机硬件架构</h3><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/2018053115277525758516.png" alt="计算机硬件架构"></p><p>CPU：一个计算机一般有多个CPU，一个CPU还会有多核</p><p>CPU Registers（寄存器）：每个CPU都包含一系列的寄存器，他们是CPU内存的基础，CPU在寄存器上执行的速度远大于在主存上执行的速度。</p><p>CPU Cache（高速缓存）：由于计算机的存储设备与处理器的处理设备有着几个数量级的差距，所以现代计算机都会加入一层读写速度与处理器处理速度接近想通的高级缓存来作为内存与处理器之间的缓冲，将运算使用到的数据复制到缓存中，让运算能够快速的执行，当运算结束后，再从缓存同步到内存之中，这样，CPU就不需要等待缓慢的内存读写了</p><p>主（内）存：一个计算机包含一个主存，所有的CPU都可以访问主存，主存比缓存容量大的多</p><p>运作原理：通常情况下，当一个CPU要读取主存的时候，他会将主存中的数据读取到CPU缓存中，甚至将缓存中的内容读到内部寄存器里面，然后再寄存器执行操作，<br>当运行结束后，会将寄存器中的值刷新回缓存中，并在某个时间点刷新回主存</p><h3 id="内存模型与硬件架构之间的关联"><a href="#内存模型与硬件架构之间的关联" class="headerlink" title="内存模型与硬件架构之间的关联"></a>内存模型与硬件架构之间的关联</h3><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180531152775282044126.png" alt="内存模型与硬件架构之间的关联"></p><p>所有线程栈和堆会被保存在缓存里面，部分可能会出现在CPU缓存中和CPU内部的寄存器里面</p><h3 id="线程和主内存之间的抽象关系"><a href="#线程和主内存之间的抽象关系" class="headerlink" title="线程和主内存之间的抽象关系"></a>线程和主内存之间的抽象关系</h3><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180531152775299434958.png" alt="线程和主内存之间的抽象关系"></p><p>每个线程之间共享变量都存放在主内存里面，每个线程都有一个私有的本地内存<br>本地内存是java内存模型中抽象的概念，并不是真实存在的（他涵盖了缓存写缓冲区。寄存器，以及其他硬件的优化），本地内存中存储了以读或者写共享变量的拷贝的一个副本，从一个更低的层次来说，线程本地内存，他是cpu缓存，寄存器的一个抽象描述，而JVM的静态内存存储模型，他只是一种对内存模型的物理划分而已，只局限在内存，而且只局限在JVM的内存</p><p>如果线程A和线程B要通信，必须经历两个过程：<br>1、A将本地内存变量刷新到主内存<br>2、B从主内存中读取变量</p><h3 id="Java内存模型-同步八种操作及规则"><a href="#Java内存模型-同步八种操作及规则" class="headerlink" title="Java内存模型-同步八种操作及规则"></a>Java内存模型-同步八种操作及规则</h3><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180531152775338016819.png" alt="同步操作与规则"></p><ul><li>lock（锁定）：作用于主内存的变量，把一个变量标识变为一条线程独占状态</li><li>unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接受到的值赋值给工作内存的变量</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中</li></ul><p><strong>同步规则：</strong></p><ol><li>如果要把一个变量从主内存中赋值到工作内存，就需要按顺序得执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序得执行store和write操作，但java内存模型只要求上述操作必须按顺序执行，没有保证必须是连续执行</li><li>不允许read和load、store和write操作之一单独出现</li><li>不允许一个线程丢弃他的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步到主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了load和assign操作</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以同时被一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会解锁，lock和unlock必须成对出现</li><li>如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎中使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许他执行unlock操作，也不允许去unlock一个被其他线程锁定的变量</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</li></ol><h2 id="并发的优势和风险"><a href="#并发的优势和风险" class="headerlink" title="并发的优势和风险"></a>并发的优势和风险</h2><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180531152775386366786.png" alt="并发的优势和风险"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CPU多级缓存&quot;&gt;&lt;a href=&quot;#CPU多级缓存&quot; class=&quot;headerlink&quot; title=&quot;CPU多级缓存&quot;&gt;&lt;/a&gt;CPU多级缓存&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xs5l8.com1.z0.glb.clouddn.com/20180531152774962796143.png&quot; alt=&quot;CPU多级缓存&quot;&gt;&lt;/p&gt;
&lt;p&gt;图左侧为最简单的高速缓存的配置，数据的读取和存储都经过高速缓存，CPU核心与高速缓存有一条特殊的快速通道；主存与高速缓存都连在系统总线上（BUS）这条总线还用于其他组件的通信。&lt;/p&gt;
&lt;p&gt;在高速缓存出现后不久，系统变得越来越复杂，高速缓存与主存之间的速度差异被拉大，直到加入了另一级缓存，新加入的这级缓存比第一缓存更大，并且更慢，由于加大一级缓存从经济上考虑是行不通的，所以有了二级缓存，甚至是三级缓存。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://shenshanlaoyuan.com/categories/Java/"/>
    
    
      <category term="高并发" scheme="http://shenshanlaoyuan.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>慕课网高并发课程笔记（一）-并发和高并发基本概念</title>
    <link href="http://shenshanlaoyuan.com/2018/05/01/Java/bingfa1/"/>
    <id>http://shenshanlaoyuan.com/2018/05/01/Java/bingfa1/</id>
    <published>2018-05-01T13:50:00.000Z</published>
    <updated>2018-08-27T07:56:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h1><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/2018053115277481628838.png" alt="Java并发编程与高并发解决方案"></p><p>课程结合大量图示及代码演示，让你更容易， 更系统的掌握多线程并发编程（线程安全，线程调度，线程封闭，同步容器等）与高并发处理思路与手段（扩容，缓存，队列，拆分等）相关知识和经验。帮助你构建完整的并发与高并发知识体系，胜任实际开发中并发与高并发问题的处理，倍增高薪面试成功率！</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2018/05/01/Java/bingfa1/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2018/05/01/Java/bingfa1/'>慕课网高并发课程笔记（一）-并发和高并发基本概念</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script><h2 id="课程地址"><a href="#课程地址" class="headerlink" title="课程地址"></a>课程地址</h2><p><a href="https://coding.imooc.com/class/195.html" target="_blank" rel="external">慕课网</a></p><p><a href="https://pan.baidu.com/s/16tDdVXjM9fcvC1cSSwCSMw" target="_blank" rel="external">百度网盘</a><br><strong>密码arkw </strong>（资源来源于网络，如有侵权联系删除！）</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程交替得换入或者换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，他通常是指，通过设计保证系统能够<strong>同时并行处理</strong>很多请求。</p><h2 id="并发和高并发对比"><a href="#并发和高并发对比" class="headerlink" title="并发和高并发对比"></a>并发和高并发对比</h2><ul><li>谈并发时：多个线程操作相同的资源，保证线程安全，合理利用资源</li><li>谈高并发时：服务能同时处理很多请求（如12306的抢票，天猫双十一的秒杀活动，这会导致系统在短时间内执行大量的操作，如对资源的请求，数据库的访问），提高程序性能（如果高并发处理不好，不光会导致用户体验不好，还可能会使服务器宕机，出现OOM等）</li></ul><h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/2018053115277476981651.png" alt="内容介绍"></p><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/2018053115277479279969.png" alt="2"></p><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180531152774805567397.png" alt="3"></p><p><img src="http://7xs5l8.com1.z0.glb.clouddn.com/20180531152774831768296.png" alt="4"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;课程介绍&quot;&gt;&lt;a href=&quot;#课程介绍&quot; class=&quot;headerlink&quot; title=&quot;课程介绍&quot;&gt;&lt;/a&gt;课程介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xs5l8.com1.z0.glb.clouddn.com/2018053115277481628838.png&quot; alt=&quot;Java并发编程与高并发解决方案&quot;&gt;&lt;/p&gt;
&lt;p&gt;课程结合大量图示及代码演示，让你更容易， 更系统的掌握多线程并发编程（线程安全，线程调度，线程封闭，同步容器等）与高并发处理思路与手段（扩容，缓存，队列，拆分等）相关知识和经验。帮助你构建完整的并发与高并发知识体系，胜任实际开发中并发与高并发问题的处理，倍增高薪面试成功率！&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://shenshanlaoyuan.com/categories/Java/"/>
    
    
      <category term="高并发" scheme="http://shenshanlaoyuan.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Python入门</title>
    <link href="http://shenshanlaoyuan.com/2018/04/07/Python/python%E5%85%A5%E9%97%A8/"/>
    <id>http://shenshanlaoyuan.com/2018/04/07/Python/python入门/</id>
    <published>2018-04-07T09:20:00.000Z</published>
    <updated>2018-04-07T09:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python入门系列电子书，搭配廖雪峰的<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external"><font color="blue">Python教程</font></a>学习效果更佳。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2018/04/07/Python/python入门/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2018/04/07/Python/python入门/'>Python入门</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script><h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><p><a href="http://shenshanlaoyuan.com/PythonTraining/linux%E5%9F%BA%E7%A1%80/"><font color="blue">Linux操作系统基础</font></a></p><p><a href="http://shenshanlaoyuan.com/PythonTraining/Python%E5%9F%BA%E7%A1%80/"><font color="blue">Python语法基础</font></a></p><h2 id="Python核心编程"><a href="#Python核心编程" class="headerlink" title="Python核心编程"></a>Python核心编程</h2><p><a href="http://shenshanlaoyuan.com/PythonTraining//Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/python%E9%AB%98%E7%BA%A7/html%E7%89%88/python%E9%AB%98%E7%BA%A7-%E8%AF%BE%E4%BB%B6/"><font color="blue">Python高级</font></a></p><p><a href="http://shenshanlaoyuan.com/PythonTraining/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/html%E7%89%88/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%8C%E6%95%B4%E8%AF%BE%E4%BB%B6/"><font color="blue">系统编程</font></a></p><p><a href="http://shenshanlaoyuan.com/PythonTraining/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/html%E7%89%88/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%85%A8%E9%83%A8%E8%AF%BE%E4%BB%B6/"><font color="blue">网络编程</font></a></p><p><a href="http://shenshanlaoyuan.com/PythonTraining/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%88%E4%BE%8B/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%88%E4%BE%8B%E8%AF%BE%E4%BB%B6/"><font color="blue">web服务器案例</font></a></p><p><a href="http://shenshanlaoyuan.com/PythonTraining/Python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%BE%E4%BB%B6/"><font color="blue">正则表达式</font></a></p><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p><a href="http://shenshanlaoyuan.com/PythonTraining/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><font color="blue">数据结构与算法</font></a></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><a href="http://shenshanlaoyuan.com/PythonTraining/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><font color="blue">MySQL</font></a></p><p><a href="http://shenshanlaoyuan.com/PythonTraining/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/"><font color="blue">mongo</font></a></p><p><a href="http://shenshanlaoyuan.com/PythonTraining/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"><font color="blue">redis</font></a></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p><a href="http://shenshanlaoyuan.com/PythonTraining/%E5%89%8D%E7%AB%AF/"><font color="blue">前端</font></a></p><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><p><a href="http://shenshanlaoyuan.com/PythonTraining/django/"><font color="blue">Django</font></a></p><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><p><a href="http://shenshanlaoyuan.com/PythonTraining/%E7%88%AC%E8%99%AB/"><font color="blue">爬虫</font></a></p><h2 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h2><p><a href="http://shenshanlaoyuan.com/PythonTraining/tornado/"><font color="blue">Tornado</font></a></p><h2 id="shell和自动化运维"><a href="#shell和自动化运维" class="headerlink" title="shell和自动化运维"></a>shell和自动化运维</h2><p><a href="http://shenshanlaoyuan.com/PythonTraining/shell/shell%E8%AF%BE%E4%BB%B6/%E8%BF%90%E7%BB%B4%E5%92%8Cshell.html"><font color="blue">shell</font></a></p><p><a href="http://shenshanlaoyuan.com/PythonTraining/shell/nginx%E8%AF%BE%E4%BB%B6/nginx%E8%AF%BE%E4%BB%B6.html"><font color="blue">nginx</font></a></p><p><a href="http://shenshanlaoyuan.com/PythonTraining/shell/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2.html"><font color="blue">自动化部署</font></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python入门系列电子书，搭配廖雪峰的&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&quot;&gt;&lt;font color=blue&gt;Python教程&lt;/font&gt;&lt;/a&gt;学习效果更佳。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://shenshanlaoyuan.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://shenshanlaoyuan.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux(CentOS) 下安装 ZooKeeper</title>
    <link href="http://shenshanlaoyuan.com/2017/05/07/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/CentOS-install-ZooKeeper/"/>
    <id>http://shenshanlaoyuan.com/2017/05/07/环境搭建/CentOS-install-ZooKeeper/</id>
    <published>2017-05-07T02:52:00.000Z</published>
    <updated>2017-05-26T06:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-单机模式-Standalone-mode"><a href="#1-单机模式-Standalone-mode" class="headerlink" title="1.单机模式(Standalone mode)"></a>1.单机模式(Standalone mode)</h2><h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><p><a href="http://apache.fayea.com/zookeeper/" target="_blank" rel="external">官网</a>下载或使用 wget 命令下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># wget http://archive.apache.org/dist/zookeeper/stable/zookeeper-3.4.9.tar.gz</div><div class="line"># tar zxf zookeeper-3.4.9.tar.gz</div></pre></td></tr></table></figure></p><p>如果 <code>wget</code> 命令找不到，先安装 wget 的 RPM 包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum -y install wget</div></pre></td></tr></table></figure></p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2017/05/07/环境搭建/CentOS-install-ZooKeeper/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2017/05/07/环境搭建/CentOS-install-ZooKeeper/'>Linux(CentOS) 下安装 ZooKeeper</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script><h3 id="启动-ZooKeeper"><a href="#启动-ZooKeeper" class="headerlink" title="启动 ZooKeeper"></a>启动 ZooKeeper</h3><p>进入 zookeeper 解压后的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cd zookeeper-3.4.9</div><div class="line"># ll</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1ffcx8fxfklj30v80iqjrz.jpg" alt=""></p><p>在目录下面创建 data 目录<br>/root/zookeeper-3.4.9/data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># mkdir data</div></pre></td></tr></table></figure></p><p>修改 conf 目录下面的 zoo_sample.cfg 配置文件名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># mv conf/zoo_sample.cfg conf/zoo.cfg</div></pre></td></tr></table></figure><p>再修改配置文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim conf/zoo.cfg</div></pre></td></tr></table></figure><p>如果没找到vim 命令先安装下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># yum -y install vim*</div></pre></td></tr></table></figure></p><p>把 dataDir 后面改成刚才创建的 data 目录全路径，如下图</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1ffcx2viortj30vc0imwfa.jpg" alt=""></p><p>进入bin目录开启 ZooKeeper<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># cd bin</div><div class="line"># ./zkServer.sh start</div></pre></td></tr></table></figure></p><p>查看是否开启开启成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ./zkServer.sh status</div></pre></td></tr></table></figure></p><p>出现如下内容开启成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /root/zookeeper-3.4.9/bin/../conf/zoo.cfg</div><div class="line">Mode: standalone</div></pre></td></tr></table></figure></p><h3 id="关闭-ZooKeeper"><a href="#关闭-ZooKeeper" class="headerlink" title="关闭 ZooKeeper"></a>关闭 ZooKeeper</h3><p>进入 bin 目录输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ./zkServer.sh stop</div></pre></td></tr></table></figure><h2 id="2-集群模式-Replicated-mode"><a href="#2-集群模式-Replicated-mode" class="headerlink" title="2.集群模式(Replicated mode)"></a>2.集群模式(Replicated mode)</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-单机模式-Standalone-mode&quot;&gt;&lt;a href=&quot;#1-单机模式-Standalone-mode&quot; class=&quot;headerlink&quot; title=&quot;1.单机模式(Standalone mode)&quot;&gt;&lt;/a&gt;1.单机模式(Standalone mode)&lt;/h2&gt;&lt;h3 id=&quot;下载解压&quot;&gt;&lt;a href=&quot;#下载解压&quot; class=&quot;headerlink&quot; title=&quot;下载解压&quot;&gt;&lt;/a&gt;下载解压&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://apache.fayea.com/zookeeper/&quot;&gt;官网&lt;/a&gt;下载或使用 wget 命令下载&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# wget http://archive.apache.org/dist/zookeeper/stable/zookeeper-3.4.9.tar.gz&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# tar zxf zookeeper-3.4.9.tar.gz&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;wget&lt;/code&gt; 命令找不到，先安装 wget 的 RPM 包&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# yum -y install wget&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="环境搭建" scheme="http://shenshanlaoyuan.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="CentOS" scheme="http://shenshanlaoyuan.com/tags/CentOS/"/>
    
      <category term="ZooKeeper" scheme="http://shenshanlaoyuan.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>解决 CentOS 安装完成后 ifconfig 命令不能用问题</title>
    <link href="http://shenshanlaoyuan.com/2017/05/07/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E8%A7%A3%E5%86%B3CentOS7%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E5%90%8Eifconfig%E5%91%BD%E4%BB%A4%E4%B8%8D%E8%83%BD%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://shenshanlaoyuan.com/2017/05/07/环境搭建/解决CentOS7安装完成后ifconfig命令不能用问题/</id>
    <published>2017-05-07T02:50:00.000Z</published>
    <updated>2017-05-26T06:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本来想查看一下本机的 ip 地址，ifconfig 命令报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ifconfig</div><div class="line">-bash: ifconfig: command not found</div></pre></td></tr></table></figure></p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2017/05/07/环境搭建/解决CentOS7安装完成后ifconfig命令不能用问题/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2017/05/07/环境搭建/解决CentOS7安装完成后ifconfig命令不能用问题/'>解决 CentOS 安装完成后 ifconfig 命令不能用问题</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="1-查看-ifconfig-命令是否存在"><a href="#1-查看-ifconfig-命令是否存在" class="headerlink" title="1.查看 ifconfig 命令是否存在"></a>1.查看 ifconfig 命令是否存在</h3><p>查看 <code>/sbin/ifconfig</code> 是否存在</p><h3 id="2-如果-ifconfig-命令不存在"><a href="#2-如果-ifconfig-命令不存在" class="headerlink" title="2.如果 ifconfig 命令不存在"></a>2.如果 ifconfig 命令不存在</h3><p>执行下面两个命令安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># yum upgrade</div><div class="line"># yum install net-tools</div></pre></td></tr></table></figure></p><h3 id="3-如果-ifconfig-命令存在，设置环境变量"><a href="#3-如果-ifconfig-命令存在，设置环境变量" class="headerlink" title="3.如果 ifconfig 命令存在，设置环境变量"></a>3.如果 ifconfig 命令存在，设置环境变量</h3><p> 临时修改环境变量：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># export PATH = $PATH:/sbin</div></pre></td></tr></table></figure></p><p>永久修改环境变量只要修改 <code>/etc/profile</code> 文件即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来想查看一下本机的 ip 地址，ifconfig 命令报错&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# ifconfig&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-bash: ifconfig: command not found&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="环境搭建" scheme="http://shenshanlaoyuan.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="CentOS" scheme="http://shenshanlaoyuan.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X下Maven的安装与配置</title>
    <link href="http://shenshanlaoyuan.com/2017/05/06/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/MacOS-Maven/"/>
    <id>http://shenshanlaoyuan.com/2017/05/06/环境搭建/MacOS-Maven/</id>
    <published>2017-05-05T20:39:00.000Z</published>
    <updated>2017-05-26T06:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven-下载"><a href="#Maven-下载" class="headerlink" title="Maven 下载"></a>Maven 下载</h2><p><a href="https://maven.apache.org/download.cgi" target="_blank" rel="external">官网下载</a>压缩包,选择 <code>Binary zip archive</code><br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1ffbqojfs9wj314e0j6dgt.jpg" alt=""></p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2017/05/06/环境搭建/MacOS-Maven/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2017/05/06/环境搭建/MacOS-Maven/'>Mac OS X下Maven的安装与配置</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script><p>打开终端，输入<code>unzip</code>和拖动这个压缩文件到终端，解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ unzip /Users/shenshanlaoyuan/Downloads/apache-maven-3.5.0-bin.zip</div></pre></td></tr></table></figure></p><p>输入<code>ls</code>,会看到<code>apache-maven-3.5.0</code>这个文件夹<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1ffbrd29legj30vg0k83z8.jpg" alt=""></p><p><code>cd</code>进入到这个文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd apache-maven-3.5.0</div></pre></td></tr></table></figure></p><p>再输入<code>pwd</code>命令得到当前文件夹全路径，选中复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pwd</div></pre></td></tr></table></figure></p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>打开终端，输入以下命令，编辑<code>bash_profile</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi ~/.bash_profile</div></pre></td></tr></table></figure></p><p>添加以下代码在最后,<code>M2_HOME=</code>后面改成刚才复制的文件夹全路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># maven</div><div class="line">export M2_HOME=/Users/shenshanlaoyuan/apache-maven-3.5.0</div><div class="line">export PATH=$PATH:$M2_HOME/bin</div></pre></td></tr></table></figure></p><p>编辑完成按ESC键跳到命令模式，输入<code>:wq</code>就能保存并退出 vi。</p><p>最后输入如下命令以使修改的<code>bash_profile</code>文件生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ source ~/.bash_profile</div></pre></td></tr></table></figure></p><h2 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn -v</div></pre></td></tr></table></figure><p>如果输出以下信息，说明 maven 安装成功了<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1ffbs6phvsfj30vi0kedh2.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Maven-下载&quot;&gt;&lt;a href=&quot;#Maven-下载&quot; class=&quot;headerlink&quot; title=&quot;Maven 下载&quot;&gt;&lt;/a&gt;Maven 下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://maven.apache.org/download.cgi&quot;&gt;官网下载&lt;/a&gt;压缩包,选择 &lt;code&gt;Binary zip archive&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006tNc79gy1ffbqojfs9wj314e0j6dgt.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="环境搭建" scheme="http://shenshanlaoyuan.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Maven" scheme="http://shenshanlaoyuan.com/tags/Maven/"/>
    
      <category term="Mac" scheme="http://shenshanlaoyuan.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Spring 框架之bean标签属性</title>
    <link href="http://shenshanlaoyuan.com/2017/03/04/Java/spring-bean-tag/"/>
    <id>http://shenshanlaoyuan.com/2017/03/04/Java/spring-bean-tag/</id>
    <published>2017-03-04T14:50:00.000Z</published>
    <updated>2017-07-02T11:07:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要有id、class、scope、init-method、destroy-method等。</p><a id="more"></a><span class='source'><blockquote><p>转载请注明出处：http://shenshanlaoyuan.com/2017/03/04/Java/spring-bean-tag/</p><p>访问原文「<a href='http://shenshanlaoyuan.com/2017/03/04/Java/spring-bean-tag/'>Spring 框架之bean标签属性</a>」获取最佳阅读体验并参与讨论</p></blockquote></span><script type="text/javascript">(function() {  Element.prototype.remove = function() {    this.parentElement.removeChild(this);  }  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {    for(var i = this.length - 1; i >= 0; i--) {        if(this[i] && this[i].parentElement) {            this[i].parentElement.removeChild(this[i]);        }    }  }  var domain = document.domain;  var white_list = ['shenshanlaoyuan.com', 'localhost'];  if (white_list.indexOf(domain) >= 0) {    var elements = document.getElementsByClassName('source');    elements.remove();  }})()</script><h2 id="id属性和name属性的区别"><a href="#id属性和name属性的区别" class="headerlink" title="id属性和name属性的区别"></a>id属性和name属性的区别</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>Bean起个名字，在约束中采用ID的约束，唯一</p><ul><li>取值要求：必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号    id:不能出现特殊字符</li></ul><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>Bean起个名字，没有采用ID的约束</p><ul><li>取值要求：name:出现特殊字符.如果<bean>没有id的话 , name可以当做id使用</bean></li><li>Spring框架在整合Struts1的框架的时候，Struts1的框架的访问路径是以 / 开头的，例如：<code>/bookAction</code></li></ul><h2 id="class属性"><a href="#class属性" class="headerlink" title="class属性"></a>class属性</h2><p>Bean对象的全路径</p><h2 id="scope属性"><a href="#scope属性" class="headerlink" title="scope属性"></a>scope属性</h2><p>scope属性代表Bean的作用范围</p><ul><li>singleton            – 单例（默认值）</li><li>prototype            – 多例，在Spring框架整合Struts2框架的时候，Action类也需要交给Spring做管理，配置把Action类配置成多例！！</li><li>request            – 应用在Web项目中,每次HTTP请求都会创建一个新的Bean</li><li>session            – 应用在Web项目中,同一个HTTP Session 共享一个Bean</li><li>globalsession        – 应用在Web项目中,多服务器间的session</li></ul><h2 id="Bean对象的创建和销毁的两个属性配置"><a href="#Bean对象的创建和销毁的两个属性配置" class="headerlink" title="Bean对象的创建和销毁的两个属性配置"></a>Bean对象的创建和销毁的两个属性配置</h2><p>Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean的时候调用bean的两个生命周期方法</p><h3 id="init-method"><a href="#init-method" class="headerlink" title="init-method"></a>init-method</h3><p>当bean被载入到容器的时候调用init-method属性指定的方法</p><h3 id="destroy-method"><a href="#destroy-method" class="headerlink" title="destroy-method"></a>destroy-method</h3><p>当bean从容器中删除的时候调用destroy-method属性指定的方法</p><p>想查看destroy-method的效果，有如下条件</p><ul><li>scope= singleton有效</li><li>web容器中会自动调用，但是main函数或测试用例需要手动调用（需要使用ClassPathXmlApplicationContext的close()方法）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要有id、class、scope、init-method、destroy-method等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://shenshanlaoyuan.com/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://shenshanlaoyuan.com/tags/Spring/"/>
    
  </entry>
  
</feed>

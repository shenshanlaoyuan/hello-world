<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[慕课网高并发课程笔记（三）-项目准备]]></title>
      <url>%2F2018%2F05%2F05%2FJava%2Fbingfa3%2F</url>
      <content type="text"><![CDATA[线程安全与线程不安全 线程安全：代码所在的进程有多个线程在同时运行，这些线程可能会同时运行同一段代码，如果每次运行的结果和单线程运行的结果一样的，而且其他的变量的值也和预期是一样的，我们就认为这是线程安全的。简单的说，就是并发环境下得到我们期望的结果。 线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据，所得到的数据是脏数据，也可能是在计算中出现错误。 转载请注明出处：http://shenshanlaoyuan.com/2018/05/05/Java/bingfa3/访问原文「慕课网高并发课程笔记（三）-项目准备」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 环境搭建与准备Spring Boot构建项目Https://start.spring.io/ 具体搭建过程参考视频。 注解的准备 线程安全的注解 1234567891011/** * 对于线程安全的类，加入一个@ThreadSafe注解的标示 * @Target(ElementType.TYPE) 说明作用于类上 * @Retention(RetentionPolicy.SOURCE) 指定注解作用的范围，在编译的时候就会被忽略掉 * @author gaowenfeng */@Target(ElementType.TYPE)@Retention(RetentionPolicy.SOURCE)public @interface ThreadSafe &#123; String value() default "";&#125; 线程不安全的注解 1234567891011/** * 用来标示[线程不安全的类] * @Target(ElementType.TYPE) 说明作用于类上 * @Retention(RetentionPolicy.SOURCE) 指定注解作用的范围，在编译的时候就会被忽略掉 * @author gaowenfeng */@Target(ElementType.TYPE)@Retention(RetentionPolicy.SOURCE)public @interface NotThreadSafe &#123; String value() default "";&#125; 推荐写法的注解 12345678/** * 用来标记[推荐]的类或者写法 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.SOURCE)public @interface Recommend &#123; String value() default "";&#125; 不推荐写法的注解 12345678/** * 用来标记[不推荐]的类或者写法 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.SOURCE)public @interface NotRecommend &#123; String value() default "";&#125; ElementType 详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ /** 声明注解作用在类，借口，枚举上*/ TYPE, /** Field declaration (includes enum constants) */ /** 声明注解作用在属性上*/ FIELD, /** Method declaration */ /** 声明注解作用在方法上*/ METHOD, /** Formal parameter declaration */ /** 声明注解作用在参数上*/ PARAMETER, /** Constructor declaration */ /** 声明注解作用在构造函数上*/ CONSTRUCTOR, /** Local variable declaration */ /** 声明注解作用在本地变量上*/ LOCAL_VARIABLE, /** Annotation type declaration */ /** 声明注解作用在注解上*/ ANNOTATION_TYPE, /** Package declaration */ /** 声明注解作用在包上*/ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ /** 声明注解可以应用在TYPE声明上*/ TYPE_PARAMETER, /** * Use of a type * Type.TYPE_USE 表示这个 Annotation 可以用在所有使用 Type 的地方（如：泛型，类型转换等） * @since 1.8 */ TYPE_USE&#125; RetentionPolicy详解1234567891011121314151617181920212223public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. * 在编译的时候会被取消，只用于声明，理解，或者测试 */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. * 注解将被编译器记录在类文件中，但在运行时不需要由VM保留，（默认的选项） */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * 注解将被编译器记录在类文件中，但在运行时由VM保留，这样他们可以被反射获取（当你需要获取注解中字段的属性值的时候，需要用这个，比如AOP） * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125; 并发模拟工具 并发模拟代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[慕课网高并发课程笔记（二）-并发基础]]></title>
      <url>%2F2018%2F05%2F04%2FJava%2Fbingfa2%2F</url>
      <content type="text"><![CDATA[CPU多级缓存 图左侧为最简单的高速缓存的配置，数据的读取和存储都经过高速缓存，CPU核心与高速缓存有一条特殊的快速通道；主存与高速缓存都连在系统总线上（BUS）这条总线还用于其他组件的通信。 在高速缓存出现后不久，系统变得越来越复杂，高速缓存与主存之间的速度差异被拉大，直到加入了另一级缓存，新加入的这级缓存比第一缓存更大，并且更慢，由于加大一级缓存从经济上考虑是行不通的，所以有了二级缓存，甚至是三级缓存。 转载请注明出处：http://shenshanlaoyuan.com/2018/05/04/Java/bingfa2/访问原文「慕课网高并发课程笔记（二）-并发基础」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 为什么需要CPU缓存？CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu-&gt;cache-&gt;memort）。 CPU缓存有什么意义？ 时间局部性：如果某个数据被访问，那么在不久的将来他很可能被再次访问 空间局部性：如果某个数据被访问，那么与他相邻的数据很快也可能被访问 CPU多级缓存-缓存一致性（MESI） M: Modified 修改，指的是该缓存行只被缓存在该CPU的缓存中，并且是被修改过的，因此他与主存中的数据是不一致的，该缓存行中的数据需要在未来的某个时间点（允许其他CPU读取主存相应中的内容之前）写回主存，然后状态变成E（独享） E：Exclusive 独享 ，缓存行只被缓存在该CPU的缓存中，是未被修改过的，与主存的数据是一致的，可以在任何时刻当有其他CPU读取该内存时，变成S（共享）状态，当CPU修改该缓存行的内容时，变成M（被修改）的状态 S：Share 共享，意味着该缓存行可能会被多个CPU进行缓存，并且该缓存中的数据与主存数据是一致的，当有一个CPU修改该缓存行时，其他CPU是可以被作废的，变成I(无效的) I：Invalid 无效的，代表这个缓存是无效的，可能是有其他CPU修改了该缓存行 用于保证多个CPU cache之间缓存共享数据的一致 local read：读本地缓存的数据 local write：将数据写到本地缓存里面 remote read：将内（主）存中的数据读取到缓存中来 remote write：将缓存中的数据写会到主存里面 在一个典型的多核系统中，每一个核都会有自己的缓存来共享主存总线，每一个CPU会发出读写（I/O）请求，而缓存的目的是为了减少CPU读写共享主存的次数；一个缓存除了在Invaild状态，都可以满足CPU 的读请求 一个写请求只有在M状态，或者E状态的时候才能给被执行，如果是处在S状态的时候，他必须先将该缓存行变成I状态，这个操作通常作用于广播的方式来完成，这个时候他既不允许不同的CPU同时修改同一个缓存行，即使是修改同一个缓存行中不同端的数据也是不可以的，这里主要解决的是缓存一致性的问题，一个M状态的缓存行必须时刻监听所有试图读该缓存行相对主存的操作，这种操作必须在缓存该缓存行被写会到主存，并将状态变成S状态之前，被延迟执行 一个处于S状态的缓存行，也必须监听其他缓存使该缓存行无效，或者独享该缓存行的请求，并将缓存行变成无效 一个处于E状态的缓存行，他要监听其他缓存读缓存行的操作，一旦有，那么他讲变成S状态 因此对于M和E状态，他们的数据总是一致的与缓存行的真正状态总是保持一致的，但是S状态可能是非一致的，如果一个缓存将处于S状态的 缓存行作废了，另一个缓存可能已经独享了该缓存行，但是该缓存缺不会讲该缓存行升迁为E状态，这是因为其他缓存不会广播他们已经作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行被COPY的数量，因此没有办法确定是否独享了改缓存行，这是一种投机性的优化，因为如果一个CPU想修改一个处于S状态的缓存行，总线需要将所有使用该缓存行的COPY的值变成Invaild状态才可以，而修改E状态的缓存 却不需要这样做 CPU多级缓存-乱序执行优化 处理器多核和缓存导致的一个问题，如果我们不做任何处理，在多核的情况下，的实际结果可能和逻辑运行结果大不相同，如果在一个核上执行数据写入操作，并在最后执行一个操作来标记数据已经写入好了，而在另外一个核上通过该标记位判定数据是否已经写入，这时候就可能出现不一致，标记位先被写入，但是实际的操作缺并未完成，这个未完成既有可能是没有计算完成，也有可能是缓存没有被及时刷新到主存之中，使得其他核读到了错误的数据 Java内存模型（Java Memory Model，JMM）JAVA内存模型规范规定了一个线程如何和何时可以看到其他线程修改过后的共享变量的值 以及何时同步的访问共享变量。 Java内存模型 Heap(堆)：java里的堆是一个运行时的数据区，堆是由垃圾回收来负责的，堆的优势是可以动态的分配内存大小，生存期也不必事先告诉编译器，因为他是在运行时动态分配内存的，java的垃圾回收器会定时收走不用的数据， 缺点是由于要在运行时动态分配，所有存取速度可能会慢一些 Stack(栈)：栈的优势是存取速度比堆要快，仅次于计算机里的寄存器，栈的数据是可以共享的，缺点是存在栈中的数据的大小与生存期必须是确定的，缺乏一些灵活性。栈中主要存放一些基本类型的变量，比如int，short，long，byte，double，float，boolean，char，对象句柄， java内存模型要求调用栈和本地内存变量存放在线程栈（Thread Stack）上，对象存放在堆上。一个本地变量可能存放一个对象的引用，这时引用变量存放在本地栈上，但是对象本身存放在堆上 成员变量跟随着对象存放在堆上，而不管是原始类型还是引用类型，静态成员变量跟随着类的定义一起存在在堆上 存在堆上的对象，可以被持有这个对象的引用的线程访问 如果两个线程同时访问同一个对象的私有变量，这时他们获得的是这个对象的私有拷贝 计算机硬件架构 CPU：一个计算机一般有多个CPU，一个CPU还会有多核 CPU Registers（寄存器）：每个CPU都包含一系列的寄存器，他们是CPU内存的基础，CPU在寄存器上执行的速度远大于在主存上执行的速度。 CPU Cache（高速缓存）：由于计算机的存储设备与处理器的处理设备有着几个数量级的差距，所以现代计算机都会加入一层读写速度与处理器处理速度接近想通的高级缓存来作为内存与处理器之间的缓冲，将运算使用到的数据复制到缓存中，让运算能够快速的执行，当运算结束后，再从缓存同步到内存之中，这样，CPU就不需要等待缓慢的内存读写了 主（内）存：一个计算机包含一个主存，所有的CPU都可以访问主存，主存比缓存容量大的多 运作原理：通常情况下，当一个CPU要读取主存的时候，他会将主存中的数据读取到CPU缓存中，甚至将缓存中的内容读到内部寄存器里面，然后再寄存器执行操作，当运行结束后，会将寄存器中的值刷新回缓存中，并在某个时间点刷新回主存 内存模型与硬件架构之间的关联 所有线程栈和堆会被保存在缓存里面，部分可能会出现在CPU缓存中和CPU内部的寄存器里面 线程和主内存之间的抽象关系 每个线程之间共享变量都存放在主内存里面，每个线程都有一个私有的本地内存本地内存是java内存模型中抽象的概念，并不是真实存在的（他涵盖了缓存写缓冲区。寄存器，以及其他硬件的优化），本地内存中存储了以读或者写共享变量的拷贝的一个副本，从一个更低的层次来说，线程本地内存，他是cpu缓存，寄存器的一个抽象描述，而JVM的静态内存存储模型，他只是一种对内存模型的物理划分而已，只局限在内存，而且只局限在JVM的内存 如果线程A和线程B要通信，必须经历两个过程：1、A将本地内存变量刷新到主内存2、B从主内存中读取变量 Java内存模型-同步八种操作及规则 lock（锁定）：作用于主内存的变量，把一个变量标识变为一条线程独占状态 unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接受到的值赋值给工作内存的变量 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中 同步规则： 如果要把一个变量从主内存中赋值到工作内存，就需要按顺序得执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序得执行store和write操作，但java内存模型只要求上述操作必须按顺序执行，没有保证必须是连续执行 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃他的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步到主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了load和assign操作 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以同时被一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会解锁，lock和unlock必须成对出现 如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎中使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许他执行unlock操作，也不允许去unlock一个被其他线程锁定的变量 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作） 并发的优势和风险]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[慕课网高并发课程笔记（一）-并发和高并发基本概念]]></title>
      <url>%2F2018%2F05%2F01%2FJava%2Fbingfa1%2F</url>
      <content type="text"><![CDATA[课程介绍 课程结合大量图示及代码演示，让你更容易， 更系统的掌握多线程并发编程（线程安全，线程调度，线程封闭，同步容器等）与高并发处理思路与手段（扩容，缓存，队列，拆分等）相关知识和经验。帮助你构建完整的并发与高并发知识体系，胜任实际开发中并发与高并发问题的处理，倍增高薪面试成功率！ 转载请注明出处：http://shenshanlaoyuan.com/2018/05/01/Java/bingfa1/访问原文「慕课网高并发课程笔记（一）-并发和高并发基本概念」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 课程地址慕课网 百度网盘密码arkw （资源来源于网络，如有侵权联系删除！） 基本概念并发同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程交替得换入或者换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。 高并发高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，他通常是指，通过设计保证系统能够同时并行处理很多请求。 并发和高并发对比 谈并发时：多个线程操作相同的资源，保证线程安全，合理利用资源 谈高并发时：服务能同时处理很多请求（如12306的抢票，天猫双十一的秒杀活动，这会导致系统在短时间内执行大量的操作，如对资源的请求，数据库的访问），提高程序性能（如果高并发处理不好，不光会导致用户体验不好，还可能会使服务器宕机，出现OOM等） 课程内容]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python入门]]></title>
      <url>%2F2018%2F04%2F07%2FPython%2Fpython%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Python入门系列电子书，搭配廖雪峰的Python教程学习效果更佳。 转载请注明出处：http://shenshanlaoyuan.com/2018/04/07/Python/python入门/访问原文「Python入门」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() Python基础Linux操作系统基础 Python语法基础 Python核心编程Python高级 系统编程 网络编程 web服务器案例 正则表达式 数据结构与算法数据结构与算法 数据库MySQL mongo redis 前端前端 DjangoDjango 爬虫爬虫 TornadoTornado shell和自动化运维shell nginx 自动化部署]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux(CentOS) 下安装 ZooKeeper]]></title>
      <url>%2F2017%2F05%2F07%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2FCentOS-install-ZooKeeper%2F</url>
      <content type="text"><![CDATA[1.单机模式(Standalone mode)下载解压官网下载或使用 wget 命令下载12# wget http://archive.apache.org/dist/zookeeper/stable/zookeeper-3.4.9.tar.gz# tar zxf zookeeper-3.4.9.tar.gz 如果 wget 命令找不到，先安装 wget 的 RPM 包1# yum -y install wget 转载请注明出处：http://shenshanlaoyuan.com/2017/05/07/环境搭建/CentOS-install-ZooKeeper/访问原文「Linux(CentOS) 下安装 ZooKeeper」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 启动 ZooKeeper进入 zookeeper 解压后的目录12# cd zookeeper-3.4.9# ll 在目录下面创建 data 目录/root/zookeeper-3.4.9/data1# mkdir data 修改 conf 目录下面的 zoo_sample.cfg 配置文件名字 1# mv conf/zoo_sample.cfg conf/zoo.cfg 再修改配置文件内容 1# vim conf/zoo.cfg 如果没找到vim 命令先安装下1# yum -y install vim* 把 dataDir 后面改成刚才创建的 data 目录全路径，如下图 进入bin目录开启 ZooKeeper12# cd bin# ./zkServer.sh start 查看是否开启开启成功1# ./zkServer.sh status 出现如下内容开启成功123ZooKeeper JMX enabled by defaultUsing config: /root/zookeeper-3.4.9/bin/../conf/zoo.cfgMode: standalone 关闭 ZooKeeper进入 bin 目录输入命令 1# ./zkServer.sh stop 2.集群模式(Replicated mode)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决 CentOS 安装完成后 ifconfig 命令不能用问题]]></title>
      <url>%2F2017%2F05%2F07%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F%E8%A7%A3%E5%86%B3CentOS7%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E5%90%8Eifconfig%E5%91%BD%E4%BB%A4%E4%B8%8D%E8%83%BD%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[本来想查看一下本机的 ip 地址，ifconfig 命令报错12# ifconfig-bash: ifconfig: command not found 转载请注明出处：http://shenshanlaoyuan.com/2017/05/07/环境搭建/解决CentOS7安装完成后ifconfig命令不能用问题/访问原文「解决 CentOS 安装完成后 ifconfig 命令不能用问题」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 解决思路1.查看 ifconfig 命令是否存在查看 /sbin/ifconfig 是否存在 2.如果 ifconfig 命令不存在执行下面两个命令安装12# yum upgrade# yum install net-tools 3.如果 ifconfig 命令存在，设置环境变量 临时修改环境变量： 1# export PATH = $PATH:/sbin 永久修改环境变量只要修改 /etc/profile 文件即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OS X下Maven的安装与配置]]></title>
      <url>%2F2017%2F05%2F06%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2FMacOS-Maven%2F</url>
      <content type="text"><![CDATA[Maven 下载官网下载压缩包,选择 Binary zip archive 转载请注明出处：http://shenshanlaoyuan.com/2017/05/06/环境搭建/MacOS-Maven/访问原文「Mac OS X下Maven的安装与配置」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 打开终端，输入unzip和拖动这个压缩文件到终端，解压1$ unzip /Users/shenshanlaoyuan/Downloads/apache-maven-3.5.0-bin.zip 输入ls,会看到apache-maven-3.5.0这个文件夹 cd进入到这个文件夹1$ cd apache-maven-3.5.0 再输入pwd命令得到当前文件夹全路径，选中复制1$ pwd 配置环境变量打开终端，输入以下命令，编辑bash_profile文件1$ vi ~/.bash_profile 添加以下代码在最后,M2_HOME=后面改成刚才复制的文件夹全路径123# mavenexport M2_HOME=/Users/shenshanlaoyuan/apache-maven-3.5.0export PATH=$PATH:$M2_HOME/bin 编辑完成按ESC键跳到命令模式，输入:wq就能保存并退出 vi。 最后输入如下命令以使修改的bash_profile文件生效1$ source ~/.bash_profile 查看是否安装成功1$ mvn -v 如果输出以下信息，说明 maven 安装成功了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring 框架之bean标签属性]]></title>
      <url>%2F2017%2F03%2F04%2FJava%2Fspring-bean-tag%2F</url>
      <content type="text"><![CDATA[主要有id、class、scope、init-method、destroy-method等。 转载请注明出处：http://shenshanlaoyuan.com/2017/03/04/Java/spring-bean-tag/访问原文「Spring 框架之bean标签属性」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() id属性和name属性的区别idBean起个名字，在约束中采用ID的约束，唯一 取值要求：必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号 id:不能出现特殊字符 nameBean起个名字，没有采用ID的约束 取值要求：name:出现特殊字符.如果没有id的话 , name可以当做id使用 Spring框架在整合Struts1的框架的时候，Struts1的框架的访问路径是以 / 开头的，例如：/bookAction class属性Bean对象的全路径 scope属性scope属性代表Bean的作用范围 singleton – 单例（默认值） prototype – 多例，在Spring框架整合Struts2框架的时候，Action类也需要交给Spring做管理，配置把Action类配置成多例！！ request – 应用在Web项目中,每次HTTP请求都会创建一个新的Bean session – 应用在Web项目中,同一个HTTP Session 共享一个Bean globalsession – 应用在Web项目中,多服务器间的session Bean对象的创建和销毁的两个属性配置Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean的时候调用bean的两个生命周期方法 init-method当bean被载入到容器的时候调用init-method属性指定的方法 destroy-method当bean从容器中删除的时候调用destroy-method属性指定的方法 想查看destroy-method的效果，有如下条件 scope= singleton有效 web容器中会自动调用，但是main函数或测试用例需要手动调用（需要使用ClassPathXmlApplicationContext的close()方法）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring 框架之Bean工厂]]></title>
      <url>%2F2017%2F03%2F04%2FJava%2Fspring-bean-factory%2F</url>
      <content type="text"><![CDATA[Spring 通过 Bean 工厂创建 Bean 对象。分别是ApplicationContext 和 BeanFactory 。 转载请注明出处：http://shenshanlaoyuan.com/2017/03/04/Java/spring-bean-factory/访问原文「Spring 框架之Bean工厂」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() ApplicationContext接口使用该工厂接口可以获取到具体的Bean对象。该接口下有两个具体的实现类 ClassPathXmlApplicationContext – 加载类路径下的Spring配置文件 FileSystemXmlApplicationContext – 加载本地磁盘下的Spring配置文件 BeanFactory工厂Spring框架早期的创建Bean对象的工厂接口 使用BeanFactory接口也可以获取到Bean对象12345public void run()&#123; BeanFactory factory = new XmlBeanFactory(new ClassPathResource("applicationContext.xml")); UserService us = (UserService) factory.getBean("us"); us.sayHello();&#125; BeanFactory 和 ApplicationContext 的区别 BeanFactory – BeanFactory 采取延迟加载，第一次getBean时才会初始化Bean ApplicationContext – 在加载applicationContext.xml时候就会创建具体的Bean对象的实例，还提供了一些其他的功能 事件传递 Bean自动装配 各种不同应用层的Context实现]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring 框架之IoC]]></title>
      <url>%2F2017%2F03%2F04%2FJava%2Fspring-IoC%2F</url>
      <content type="text"><![CDATA[什么是IoC?Inversion of Control，控制反转,英文缩写为IoC。将对象的创建权交给了Spring。 使用IoC可以解决程序耦合性高的问题。 转载请注明出处：http://shenshanlaoyuan.com/2017/03/04/Java/spring-IoC/访问原文「Spring 框架之IoC」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 简单IoC示例步骤一:下载Spring的开发包官网或者下载地址下载 解压后目录结构: docs :API和开发规范. libs :jar包和源码. schema :约束. 步骤二:创建web项目,引入Spring的开发包 步骤三:创建Spring配置文件在src目录下创建applicationContext.xml文件123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 使用bean标签 --&gt; &lt;bean id="userService" class="com.shenshanlaoyuan.demo.UserServiceImpl"&gt; &lt;/bean&gt;&lt;/beans&gt; 步骤四:编写相关的类123public interface UserService &#123; public void sayHello();&#125; 12345678public class UserServiceImpl implements UserService &#123; @Override public void sayHello() &#123; System.out.println("hello spring"); &#125;&#125; 步骤五:配置Bean在applicationContext.xml文件beans标签下添加bean12&lt;bean id="userService" class="com.shenshanlaoyuan.demo.UserServiceImpl"&gt;&lt;/bean&gt; 步骤六:编写测试类1234567891011121314151617181920212223/** * 测试类 * @author shenshanlaoyuan * */public class TestService &#123; //原来的方式 @Test public void testSayHello1()&#123; UserServiceImpl usi = new UserServiceImpl(); usi.sayHello(); &#125; //spring方式 @Test public void testSayHello2()&#123; //创建工厂，加载配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); //从工厂中获取到对象 UserService us = (UserService) ac.getBean("userService"); //调用对象的方法 us.sayHello(); &#125;&#125; 示例源代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring 框架之框架概述]]></title>
      <url>%2F2017%2F03%2F03%2FJava%2Fspring-summary%2F</url>
      <content type="text"><![CDATA[什么是 Spring？ Spring 是一个开源框架。 Spring 是于2003 年兴起的一个轻量级的 Java 开发框架，由 Rod Johnson 在其著作 Expert One-On-One J2EE Development and Design 中阐述的部分理念和原型衍生而来。 它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。 Spring 使用基本的 JavaBean 来完成以前只可能由EJB完成的事情。然而，Spring 的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何 Java 应用都可以从 Spring 中受益。 Spring 的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring 是一个分层的 JavaSE/EEfull-stack(一站式) 轻量级开源框架。 转载请注明出处：http://shenshanlaoyuan.com/2017/03/03/Java/spring-summary/访问原文「Spring 框架之框架概述」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 为什么用 Spring？ 方便解耦，简化开发 Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理AOP编程的支持 AOP编程的支持 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 声明式事务的支持 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序的测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序 方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持 降低JavaEE API的使用难度 Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[引入开源项目的正确姿势]]></title>
      <url>%2F2017%2F02%2F27%2FAndroid%2F%E5%BC%95%E5%85%A5%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%2F</url>
      <content type="text"><![CDATA[为什么要用开源项目？软件开发领域一直有一个原则，DRY，Don’t repeat yourself，翻译过来就是”不要重复造轮子“。一个项目的开发，我们不可能一切从 0 开始，如果真要那样··· 开源项目的主要目的是共享，其实就为了让大家不要重复造轮子，尤其在互联网这个快速发展的领域，速度就是生命，引入开源项目，可以节省大量的人力和时间。 虽说开源项目为我们节省了大量的人力和时间，但是开源项目并不是完美的，相信使用过开源项目的人都大大小小踩过一些坑，如代码不规范啊，项目有 bug 啊等等，出了问题都会为我们的项目以及公司带来不小的影响，这个时候如何选择开源项目就变得很重要。 转载请注明出处：http://shenshanlaoyuan.com/2017/02/27/Android/引入开源项目的正确姿势/访问原文「引入开源项目的正确姿势」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 如何选择开源项目1.看 Star 数一般来说都会选则按 Star 数来排序，当然 Star 数高不代表是完美的，但起码说明该项目蛮火的，不然也不会那么多人 Star 的。 2.看作者如 JakeWharton 大神、Facebook 团队等。大神和大公司出品的框架质量相对较高，可保证后续的维护和 Bug 修复，不容易烂尾。 3.看最后更新时间、Issues、Fork 等GitHub上有些的项目好几个月甚至一年没更新了，对于一个开源项目来说最怕的是作者不维护了，这就意味着之后再也不会有改进了，而且出了什么问题也很难被迅速解决。 总结对于开源项目的选择，没有哪个最好的，你只有在综合评估的指标下，选择一个相对来说成熟并且适合你自己的就好了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5新增的元素和移除的元素]]></title>
      <url>%2F2016%2F10%2F01%2FWeb%2FHTML5%E6%96%B0%E5%A2%9E%E7%9A%84%E5%85%83%E7%B4%A0%E5%92%8C%E7%A7%BB%E9%99%A4%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[为了更好地处理今天的互联网应用，HTML5添加了很多新元素及功能，比如: 图形的绘制，多媒体内容，更好的页面结构，更好的形式 处理，和几个api拖放元素，定位，包括网页 应用程序缓存，存储，网络工作者，等。 转载请注明出处：http://shenshanlaoyuan.com/2016/10/01/Web/HTML5新增的元素和移除的元素/访问原文「HTML5新增的元素和移除的元素」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 新元素新的语义和结构元素 元素 描述 &lt;article&gt; 定义独立的内容，内容本身必须是有意义的且必须是独立于文档的其余部分。 &lt;aside&gt; 定义页面的侧边栏内容。 &lt;header&gt; 定义了文档的头部区域。 &lt;footer&gt; 定义文档或者文档的一部分区域的页脚。 &lt;section&gt; 定义了文档的某个区域。比如章节、头部、底部或者文档的其他区域。 &lt;time&gt; 定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。 &lt;details&gt; 规定了用户可见的或者隐藏的需求的补充细节。标签用来供用户开启关闭的交互式控件。任何形式的内容都能被放在 &lt;details&gt; 标签里边。元素的内容对用户是不可见的，除非设置了 open 属性。 &lt;bdi&gt; 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。在发布用户评论或其他您无法完全控制的内容时，该标签很有用。 &lt;summary&gt; 标签为 &lt;details&gt;元素定义一个可见的标题。 当用户点击标题时会显示出详细信息。 &lt;command&gt; 定义命令按钮，比如单选按钮、复选框或按钮。 &lt;dialog&gt; 定义对话框，比如提示框。 &lt;figure&gt; 标签规定独立的流内容（图像、图表、照片、代码等等）。元素的内容应该与主内容相关，同时元素的位置相对于主内容是独立的。如果被删除，则不应对文档流产生影响。 &lt;figcaption&gt; 定义&lt;figure&gt;元素的标题 &lt;mark&gt; 定义带有记号的文本。 &lt;meter&gt; 标签定义度量衡。仅用于已知最大和最小值的度量。比如：磁盘使用情况，查询结果的相关性等。 &lt;nav&gt; 标签定义导航链接的部分。并不是所有的HTML文档都要使用到 &lt;nav&gt; 元素。&lt;nav&gt;元素只是作为标注一个导航链接的区域。 &lt;progress&gt; 标签定义运行中的任务进度（进程）。 &lt;rt&gt; 定义字符（中文注音或字符）的解释或发音。 新表单元素 标签 描述 &lt;datalist&gt; 标签规定了 &lt;input&gt; 元素可能的选项列表。标签被用来在为 &lt;input&gt; 元素提供”自动完成”的特性。用户能看到一个下拉列表，里边的选项是预先定义好的，将作为用户的输入数据。 &lt;keygen&gt; 标签规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。 &lt;output&gt; 标签作为计算结果输出显示(比如执行脚本的输出)。 新多媒体元素 标签 描述 &lt;audio&gt; 标签定义声音，比如音乐或其他音频流。&lt;audio&gt;元素支持的3种文件格式：MP3、Wav、Ogg。 &lt;video&gt; 标签定义视频，比如电影片段或其他视频流。目前，&lt;video&gt; 元素支持三种视频格式：MP4、WebM、Ogg。 &lt;source&gt; 标签为媒体元素（比如 &lt;video&gt;和 &lt;audio&gt;）定义媒体资源。 &lt;embed&gt; 标签定义了一个容器，用来嵌入外部应用或者互动程序（插件）。 &lt;track&gt; 标签为媒体元素（比如 &lt;audio&gt;and&lt;video&gt;）规定外部文本轨道。这个元素用于规定字幕文件或其他包含文本的文件，当媒体播放时，这些文件是可见的。 &lt;canvas&gt;元素标签通过脚本（通常是 JavaScript）来绘制图形（比如图表和其他图像）。&lt;canvas&gt;标签只是图形容器，必须使用脚本来绘制图形。 移除的元素 &lt;acronym&gt; &lt;applet&gt; &lt;basefont&gt; &lt;big&gt; &lt;center&gt; &lt;dir&gt; &lt;font&gt; &lt;frame&gt; &lt;frameset&gt; &lt;noframes&gt; &lt;strike&gt; &lt;tt&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决GitHub Pages自有域名二级目录无法访问问题]]></title>
      <url>%2F2016%2F09%2F26%2FHexo%2F%E8%A7%A3%E5%86%B3GitHub%20Pages%E8%87%AA%E6%9C%89%E5%9F%9F%E5%90%8D%E4%BA%8C%E7%BA%A7%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[问题描述通常新建个项目，通过GitHub上创建gh-pages分支可以访问项目主页。然而我访问usename.github.io/repo,或者自定义域名 yoursite.com/repo ，跳转到了 404 页面。 分析自己把博客同时放在 GitHub 和 Coding上，通过 DNS 做了不同线路解析，通过 CNAME 文件绑定了自己的自定义域名。GitHub 可以创建一个个人主页和多个项目主页，一般这样访问是没有问题。我的问题出现在域名解析这，默认线路设置为解析到 Coding 了，显然 Coding 上找不到 GitHub 创建的项目主页，就去博客目录下去找 /repo 目录，肯定找不到啦。 转载请注明出处：http://shenshanlaoyuan.com/2016/09/26/Hexo/解决GitHub Pages自有域名二级目录无法访问问题/访问原文「解决GitHub Pages自有域名二级目录无法访问问题」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 解决方法 我这个问题在域名解析商DNSPAD把解析线路默认改为GitHub就可以了 也可以在 DNS解析增加一条 CNAME 记录，通过 repo.yoursite.com 访问 还可以把项目主页放到博客themes/themes-name/source目录下 有问题欢迎下面留言]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[该重新学习下前端知识了]]></title>
      <url>%2F2016%2F09%2F24%2F%E9%9A%8F%E7%AC%94%2F%E8%AF%A5%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0%E4%B8%8B%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BA%86%2F</url>
      <content type="text"><![CDATA[前几天微博朋友圈被微信小程序刷屏了。虽说现在只是内测，但微博Q群里都讨论炸了，可见微信对移动互联网影响多大。 转载请注明出处：http://shenshanlaoyuan.com/2016/09/24/随笔/该重新学习下前端知识了/访问原文「该重新学习下前端知识了」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 什么是微信小程序？微信之父张小龙是这样说的： 小程序会取代原生？微博群里讨论的激烈，无非是担心自己会不会失业。小程序一经推出，各种预言家出来了，说App将被颠覆，原生已死。在我看来，远没到那个地步。就像H5刚出来的时候就有人说会取代原生应用，然后直到现在原生APP还活的好好的，就连目前大火的ReactNative还有很多不完善的地方。取代原生的开发不可能，毕竟有很多的APP在微信小程序还是有很多限制的，比如游戏，一些大型APP。不过也要开始学习下Javascript了，毕竟多学一项技能就会多一份竞争力，总会有好处的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Banner轮播图效果实现]]></title>
      <url>%2F2016%2F09%2F02%2FAndroid%2FBanner%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[项目中常常需要用到如下图的 Banner 广告轮播图的效果,利用 ViewPager 实现。 转载请注明出处：http://shenshanlaoyuan.com/2016/09/02/Android/Banner轮播图效果实现/访问原文「Banner轮播图效果实现」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 布局123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.shenshanlaoyuan.viewpagertest.MainActivity" &gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="180dp" &gt; &lt;android.support.v4.view.ViewPager android:id="@+id/pager" android:layout_width="match_parent" android:layout_height="180dp" &gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:background="#33000000" android:orientation="vertical" android:padding="5dp" &gt; &lt;TextView android:id="@+id/tv_title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:text="图片的title" android:textColor="@android:color/white" /&gt; &lt;!-- 装圆点的容器 --&gt; &lt;LinearLayout android:id="@+id/point_container" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginTop="5dp" android:orientation="horizontal" &gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt;&lt;/RelativeLayout&gt; 圆点资源目录 res 下新建 drawable 目录，创建两个圆点 shape 文件 point_normal.xml 文件内容123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" &gt; &lt;corners android:radius="5dp" /&gt; &lt;solid android:color="@android:color/white" /&gt;&lt;/shape&gt; point_selected.xml 文件内容123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval" &gt; &lt;corners android:radius="5dip"/&gt; &lt;solid android:color="#ff0000"/&gt;&lt;/shape&gt; 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package com.shenshanlaoyuan.viewpagertest;import java.util.ArrayList;import java.util.List;import android.app.Activity;import android.os.Bundle;import android.support.v4.view.PagerAdapter;import android.support.v4.view.ViewPager;import android.support.v4.view.ViewPager.OnPageChangeListener;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import android.widget.ImageView.ScaleType;import android.widget.LinearLayout;import android.widget.LinearLayout.LayoutParams;public class MainActivity extends Activity implements OnPageChangeListener &#123; private ViewPager mPager; private LinearLayout mPointContainer; private List&lt;ImageView&gt; mListDatas; private TextView mTitle; //一般从网络获取数据，这里模拟本地获取数据,要在drawable目录添加五张图片 String[] titles = &#123; "第一个页面", "第二个页面", "第三个页面", "第四个页面", "第五个页面" &#125;; int[] imgs = &#123; R.drawable.a, R.drawable.b, R.drawable.c, R.drawable.d, R.drawable.e &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mPager = (ViewPager) findViewById(R.id.pager); mPointContainer = (LinearLayout) findViewById(R.id.point_container); mTitle = (TextView) findViewById(R.id.tv_title); // 初始化数据 mListDatas = new ArrayList&lt;ImageView&gt;(); for (int i = 0; i &lt; imgs.length; i++) &#123; // 给集合添加ImageView ImageView iv = new ImageView(this); iv.setImageResource(imgs[i]); //图片拉伸 iv.setScaleType(ScaleType.FIT_XY); mListDatas.add(iv); // 添加圆点 View point = new View(this); point.setBackgroundResource(R.drawable.point_normal); LayoutParams params = new LayoutParams(10, 10); if (i != 0) &#123; params.leftMargin = 10; &#125; else &#123; point.setBackgroundResource(R.drawable.point_selected); mTitle.setText(titles[i]); &#125; //向容器LinearLayout中添加圆点 mPointContainer.addView(point, params); &#125; // 设置适配器 mPager.setAdapter(new MyAdapter()); // 设置监听器 mPager.addOnPageChangeListener(this); // 设置默认选中中间的item，实现循环轮播的效果 int middle = Integer.MAX_VALUE / 2; int extra = middle % mListDatas.size(); int item = middle - extra; mPager.setCurrentItem(item); &#125; class MyAdapter extends PagerAdapter &#123; // 页面的数量 @Override public int getCount() &#123; if (mListDatas != null) &#123; return Integer.MAX_VALUE; &#125; return 0; &#125; // 标记方法，用来判断缓存标记 // view:显示的view // object: 标记 @Override public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; // 初始化item @Override public Object instantiateItem(ViewGroup container, int position) &#123; position = position % mListDatas.size(); // position： 要加载的位置 ImageView iv = mListDatas.get(position); // 用来添加要显示的View的 mPager.addView(iv); // 返回记录缓存标记 return iv; &#125; // 销毁item条目 // object:缓存标记 @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; position = position % mListDatas.size(); ImageView iv = mListDatas.get(position); mPager.removeView(iv); &#125; &#125; /************************************* ViewPager监听回调方法 *******************************************/ // 回调方法,当viewpager的滑动状态改变时的回调 // * @see ViewPager#SCROLL_STATE_IDLE : 闲置状态 // * @see ViewPager#SCROLL_STATE_DRAGGING :拖动状态 // * @see ViewPager#SCROLL_STATE_SETTLING: 固定状态 @Override public void onPageScrollStateChanged(int state) &#123; &#125; // 回调方法,当viewpager滚动时的回调 // position: 当前选中的位置 // positionOffset: 滑动的百分比 // positionOffsetPixels: 偏移的距离,滑动的像素 @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; // 回调方法,当viewpager的某个页面选中时的回调 @Override public void onPageSelected(int position) &#123; position = position % mListDatas.size(); // 设置选中的点的样式 int count = mPointContainer.getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View view = mPointContainer.getChildAt(i); view.setBackgroundResource(position == i ? R.drawable.point_selected : R.drawable.point_normal); &#125; // 设置标题 mTitle.setText(titles[position]); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dip(独立像素)和px(像素)之间转换]]></title>
      <url>%2F2016%2F06%2F15%2FUtils%2Fdip(%E7%8B%AC%E7%AB%8B%E5%83%8F%E7%B4%A0)%E5%92%8Cpx(%E5%83%8F%E7%B4%A0)%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[dip(dp): 与设备无关的像素，与“像素密度”密切相关，推荐使用 px: 普通像素 转载请注明出处：http://shenshanlaoyuan.com/2016/06/15/Utils/dip(独立像素)和px(像素)之间转换/访问原文「dip(独立像素)和px(像素)之间转换」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 1234567891011121314151617public class DensityUtil &#123; /** * 根据手机的分辨率从 dip(独立像素) 的单位 转成为 px(像素) */ public static int dip2px(Context context, float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; /** * 根据手机的分辨率从 px(像素) 的单位 转成为 dp(dip) */ public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The type org.apache.http.HttpResponse cannot be resolved. It is indirectly referenced from required .class files]]></title>
      <url>%2F2016%2F06%2F13%2FAndroid%2FThe%20type%20org.apache.http.HttpResponse%20cannot%20be%20resolved.%20It%20is%20indirectly%20referenced%20from%20required%20.class%20files%2F</url>
      <content type="text"><![CDATA[在 Android 6.0（API 23）中，Google 已经移除了移除了Apache HttpClient 相关的类、HttpResponse 类。缺失jar包使用HttpResponse等会报错：The type org.apache.http.HttpResponse cannot be resolved. It is indirectly referenced from required 转载请注明出处：http://shenshanlaoyuan.com/2016/06/13/Android/The type org.apache.http.HttpResponse cannot be resolved. It is indirectly referenced from required .class files/访问原文「The type org.apache.http.HttpResponse cannot be resolved. It is indirectly referenced from required .class files」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 1234567891011121314151617//获取网络数据HttpUtils httpUtils = new HttpUtils();//发送URL请求 httpUtils.send(HttpMethod.GET, MyConstants.NEWSCENTERURL, new RequestCallBack&lt;String&gt;() &#123; @Override public void onSuccess(ResponseInfo&lt;String&gt; responseInfo) &#123; //访问数据成功 String jsonData = responseInfo.result; System.out.println(jsonData); &#125; @Override public void onFailure(HttpException error, String msg) &#123; //访问数据失败 System.out.println("网络请求数据失败：" + error); &#125;&#125;); 解决方法推荐使用HttpUrlConnection，如果要继续使用需要Apache HttpClient，需要在eclipse下libs里添加org.apache.http.legacy.jar。添加方法如下： Eclipse中 在错误原因上点击ctrl+1，选择Configure build path，或者Project-&gt;Properties-&gt;Java Build Path-&gt;Libraries-&gt;Add Ecternal JARS-&gt;你的SDK目录的 android studio里在相应的module下的build.gradle中加入： 123android &#123;useLibrary 'org.apache.http.legacy'&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MD5加密]]></title>
      <url>%2F2016%2F06%2F10%2FUtils%2FMD5%E5%8A%A0%E5%AF%86%2F</url>
      <content type="text"><![CDATA[为了不让别人看直接看到保存的密码等信息，通常密码先采用MD5加密后再保存。MD5加密不可逆的，网上破解MD5方法原理是，拿MD5加密后的数据去他们亿万级的数据库去匹配。要防止别人破解可以用加密后数据再MD5加密几次，像银行保存的密码信息至少加密十次以上。 转载请注明出处：http://shenshanlaoyuan.com/2016/06/10/Utils/MD5加密/访问原文「MD5加密」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 下图是某破解网站能破解的数据，也只能破解三次加密，而且还是收费，所以担心破解可以多加密几次。 MD5加密工具类：1234567891011121314151617181920212223242526public class Md5Utils &#123; public static String md5(String str)&#123; StringBuilder mess = new StringBuilder(); try &#123; //获取MD5加密器 MessageDigest md = MessageDigest.getInstance("MD5"); byte[] bytes = str.getBytes(); byte[] digest = md.digest(bytes); for (byte b : digest)&#123; //把每个字节转成16进制数 int d = b &amp; 0xff;// 0x000000ff String hexString = Integer.toHexString(d); if (hexString.length() == 1) &#123;//字节的高4位为0 hexString = "0" + hexString; &#125; mess.append(hexString);//把每个字节对应的2位十六进制数当成字符串拼接一起 &#125; &#125; catch (NoSuchAlgorithmException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return mess + ""; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最爱听民谣]]></title>
      <url>%2F2016%2F06%2F03%2F%E9%9A%8F%E7%AC%94%2F%E6%9C%80%E7%88%B1%E5%90%AC%E6%B0%91%E8%B0%A3%2F</url>
      <content type="text"><![CDATA[转载请注明出处：http://shenshanlaoyuan.com/2016/06/03/随笔/最爱听民谣/访问原文「最爱听民谣」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前面些文章写的有点水了]]></title>
      <url>%2F2016%2F06%2F02%2F%E9%9A%8F%E7%AC%94%2F%E5%89%8D%E9%9D%A2%E4%BA%9B%E6%96%87%E7%AB%A0%E5%86%99%E7%9A%84%E6%9C%89%E7%82%B9%E6%B0%B4%E4%BA%86%2F</url>
      <content type="text"><![CDATA[因为是第一次写博客，可能前面些文章技术含量很低，后面尽量多写点有质量的文章。 转载请注明出处：http://shenshanlaoyuan.com/2016/06/02/随笔/前面些文章写的有点水了/访问原文「前面些文章写的有点水了」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 以前语文作文很少及格，所以文笔太差了，见谅，呵呵。不过我相信多写写就会好些。 我为什么写博客？一直记得原来的语文老师说的那句，“好记性不如烂笔头”。确实是这样，以前学的东西现在好多都忘记了，多写写文章能加深印象。还有就是，比如现在正在学某些知识，写不出来也证明脑子里面没有记忆，也就是没学进去。所以以后一定要多把工作学习中的知识整理下写出来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dialog]]></title>
      <url>%2F2016%2F05%2F23%2FAndroid%2FDialog%2F</url>
      <content type="text"><![CDATA[几种常见的对话框使用。 确认取消对话框123456789101112131415 AlertDialog.Builder builder = new AlertDialog.Builder(this);builder.setTitle("约会把...");builder.setMessage("告别单身, 你愿意吗 ?");builder.setPositiveButton("愿意,gogogo", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, "我也单身, 说不定 可以 来找我...", 0).show(); &#125;&#125;);builder.setNegativeButton("不愿意", null );builder.show(); 显示效果： 转载请注明出处：http://shenshanlaoyuan.com/2016/05/23/Android/Dialog/访问原文「Dialog」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 单选对话框12345678910111213141516AlertDialog.Builder builder = new AlertDialog.Builder(this);builder.setTitle("单选对话框 ");final String[] items = &#123; "小丽", "小红", "小芳" &#125;;builder.setSingleChoiceItems(items, -1, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, " 被点击了 : " + items[which] + ",位置: " + which, 0) .show(); &#125; &#125;);builder.show(); 效果： 多选对话框12345678910111213141516171819AlertDialog.Builder builder = new AlertDialog.Builder(this);builder.setTitle("多选");final String[] items = &#123; "android", "ios", "javaee", "php", "C++" &#125;;boolean[] checkedItems = &#123; true, true, false, false, false &#125;;builder.setMultiChoiceItems(items, checkedItems, new DialogInterface.OnMultiChoiceClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which, boolean isChecked) &#123; Toast.makeText( MainActivity.this, " 被点击了 : " + items[which] + ",位置: " + which + ", 值是: " + isChecked, 0).show(); &#125; &#125;);builder.show(); 显示效果： 进度对话框123456789101112 ProgressDialog pd = new ProgressDialog(this);// 设置对话框的标题pd.setTitle("任务正在执行中");// 设置对话框显示的内容pd.setMessage("任务正在执行中，敬请等待...");// 设置对话框能用“取消”按钮关闭pd.setCancelable(true);// 设置对话框的进度条风格pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);// 设置对话框的进度条是否显示进度pd.setIndeterminate(true);pd.show(); 显示效果： 进度对话框带-进度条的1234567891011121314151617181920212223242526272829final ProgressDialog progress = new ProgressDialog(this);progress.setMessage("正在下载中。。。");progress.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);// progress.setIndeterminate(true);progress.show();final int totalProgressTime = 100;final Thread t = new Thread() &#123; @Override public void run() &#123; int jumpTime = 0; while (jumpTime &lt; totalProgressTime) &#123; try &#123; sleep(200); jumpTime += 5; progress.setProgress(jumpTime); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;;t.start(); 显示效果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android下的数据存储与访问方式（三）]]></title>
      <url>%2F2016%2F05%2F21%2FAndroid%2FAndroid%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[更多方式阅读上两篇文章：Android下的数据存储与访问方式（一）Android下的数据存储与访问方式（二） SQLite 轻量级数据库SQLite，是一款轻型的数据库，是遵守ACID(原子性、一致性、隔离性、持久性)的关联式数据库管理系统，多用于嵌入式开发中。 SQLite的数据类型：Typelessness(无类型), 可以保存任何类型的数据到你所想要保存的任何表的任何列中. 但它又支持常见的类型比如: NULL, VARCHAR, TEXT, INTEGER, BLOB, CLOB…等. 唯一的例外：integer primary key 此字段只能存储64位整数。 转载请注明出处：http://shenshanlaoyuan.com/2016/05/21/Android/Android下的数据存储与访问方式（三）/访问原文「Android下的数据存储与访问方式（三）」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 在Android系统，提供了一个SQLiteOpenHelper抽象类，该类用于对数据库版本进行管理.该类中常用的方法: onCreate 数据库创建时执行(第一次连接获取数据库对象时执行) onUpgrade 数据库更新时执行(版本号改变时执行) onOpen 数据库每次打开时执行(每次打开数据库时调用，在 onCreate，onUpgrade方法之后) 使用SQLiteDatabase操作SQLite数据库Android提供了一个名为SQLiteDatabase的类，该类封装了一些操作数据库的API，使用该类可以完成对数据进行添加(Create)、查询(Retrieve)、更新(Update)和删除(Delete)操作（这些操作简称为CRUD）。 对SQLiteDatabase的学习，我们应该重点掌握execSQL()和rawQuery()方法。 execSQL()方法可以执行insert、delete、update和CREATE TABLE之类有更改行为的SQL语句； rawQuery()方法用于执行select语句。 1.execSQL()方法的使用例子： 1234MySqliteHelper helper = new MySqliteHelper();SQLiteDatabase db = helper.getWritableDatabase();db.execSQL("insert into person(name, age) values('张三', 4)");db.close(); 执行上面SQL语句会往person表中添加进一条记录，在实际应用中， 语句中的“张三”这些参数值会由用户输入界面提供，如果把用户输入的内容原样组拼到上面的insert语句， 当用户输入的内容含有单引号时，组拼出来的SQL语句就会存在语法错误。要解决这个问题需要对单引号进行转义，也就是把单引号转换成两个单引号。有些时候用户往往还会输入像“ &amp; ”这些特殊SQL符号，为保证组拼好的SQL语句语法正确，必须对SQL语句中的这些特殊SQL符号都进行转义，显然，对每条SQL语句都做这样的处理工作是比较烦琐的。 SQLiteDatabase类提供了一个重载后的execSQL(String sql, Object[] bindArgs)方法，使用这个方法可以解决前面提到的问题，因为这个方法支持使用占位符参数(?)。使用例子如下：1234MySqliteHelper helper = new MySqliteHelper();SQLiteDatabase db = helper.getWritableDatabase();db.execSQL("insert into person(name, age) values(?,?)", new Object[]&#123;"张三", 4&#125;); db.close(); execSQL(String sql, Object[] bindArgs)方法的第一个参数为SQL语句，第二个参数为SQL语句中占位符参数的值，参数值在数组中的顺序要和占位符的位置对应。 2.SQLiteDatabase的rawQuery() 用于执行select语句，使用例子如下： 12345678910MySqliteHelper helper = new MySqliteHelper();SQLiteDatabase db = helper.getReadableDatabase();Cursor cursor = db.rawQuery(“select * from person”, null);while (cursor.moveToNext()) &#123; int personid = cursor.getInt(0); //获取第一列的值,第一列的索引从0开始 String name = cursor.getString(1);//获取第二列的值 int age = cursor.getInt(2);//获取第三列的值&#125;cursor.close();db.close(); rawQuery()方法的第一个参数为select语句；第二个参数为select语句中占位符参数的值，如果select语句没有使用占位符，该参数可以设置为null。 带占位符参数的select语句使用例子如下：1Cursor cursor = db.rawQuery("select * from person where name like ? and age=?", new String[]&#123;"%张%", "4"&#125;); Cursor是结果集游标，用于对结果集进行随机访问，如果熟悉jdbc， 其实Cursor与JDBC中的ResultSet作用很相似。使用moveToNext()方法可以将游标从当前行移动到下一行，如果已经移过了结果集的最后一行，返回结果为false，否则为true。另外Cursor 还有常用的moveToPrevious()方法（用于将游标从当前行移动到上一行，如果已经移过了结果集的第一行，返回值为false，否则为true ）、moveToFirst()方法（用于将游标移动到结果集的第一行，如果结果集为空，返回值为false，否则为true ）和moveToLast()方法（用于将游标移动到结果集的最后一行，如果结果集为空，返回值为false，否则为true ） 。 除了execSQL()和rawQuery()方法, SQLiteDatabase还专门提供了对应于添加、删除、更新、查询的操作方法： insert() 增加数据 delete() 删除数据 update() 修改数据 query() 查询数据 这些方法实际上是给那些不太了解SQL语法的开发者使用的，对于熟悉SQL语法的程序员而言，直接使用execSQL()和rawQuery()方法执行SQL语句就能完成数据的添加、删除、更新、查询操作。 使用事务操作SQLite数据库使用SQLiteDatabase的beginTransaction()方法可以开启一个事务，程序执行到endTransaction() 方法时会检查事务的标志是否为成功，如果程序执行到endTransaction()之前调用了setTransactionSuccessful() 方法设置事务的标志为成功则提交事务，如果没有调用setTransactionSuccessful() 方法则回滚事务。使用例子如下：12345678910SQLiteDatabase db = ....;db.beginTransaction();//开始事务try &#123; db.execSQL("insert into person(name, age) values(?,?)", new Object[]&#123;"张三", 4&#125;); db.execSQL("update person set name=? where personid=?", new Object[]&#123;"李四", 1&#125;); db.setTransactionSuccessful();//调用此方法会在执行到endTransaction() 时提交当前事务，如果不调用此方法会回滚事务&#125; finally &#123; db.endTransaction();//由事务的标志决定是提交事务，还是回滚事务&#125; db.close(); 上面两条SQL语句在同一个事务中执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客添加Fork me on GitHub]]></title>
      <url>%2F2016%2F05%2F20%2FHexo%2F%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Fork%20me%20on%20GitHub%2F</url>
      <content type="text"><![CDATA[效果如下所示： 转载请注明出处：http://shenshanlaoyuan.com/2016/05/20/Hexo/博客添加Fork me on GitHub/访问原文「博客添加Fork me on GitHub」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 去网址https://github.com/blog/273-github-ribbons挑选自己喜欢的样式，并复制代码。 修改主题文件。以我用的next主题为例,粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中，修改后的的文件内容如下 再把其中的链接地址改为你的github地址。如上图修改红框中地址。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XML文件的生成与解析]]></title>
      <url>%2F2016%2F05%2F16%2FAndroid%2FXML%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[我们知道SharedPreference背后是用XMl文件进行数据存储的，那么Android下是如何生成XMl文件，如何解析XML文件的呢？ 转载请注明出处：http://shenshanlaoyuan.com/2016/05/16/Android/XML文件的生成与解析/访问原文「XML文件的生成与解析」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 生成XML文件原始拼接的方法假如要生成如下内容的XML文件123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;number&gt;123456&lt;/number&gt; &lt;sex&gt;男&lt;/sex&gt;&lt;/student&gt; 那么拼接方式的代码实现如下1234567891011121314151617 File file = new File(getFilesDir(),"张三.xml");StringBuilder sb = new StringBuilder();sb.append("&lt;?xml version='1.0' encoding='utf-8'?&gt;");sb.append("&lt;student&gt;");sb.append("&lt;name&gt;");sb.append("张三");sb.append("&lt;/name&gt;");sb.append("&lt;number&gt;");sb.append("123456");sb.append("&lt;/number&gt;");sb.append("&lt;sex&gt;");sb.append("男");sb.append("&lt;/sex&gt;");sb.append("&lt;/student&gt;");OutputStream out = new FileOutputStream(file);out.write(sb.toString().getBytes());out.close(); 使用序列化器Serializer如果XMl文件内接收的内容含有特殊字符，使用Serializer就不需要手动做判断转义了，自动帮我们完成了转义。 使用Serializer生成XMl代码如下:123456789101112131415161718192021222324252627 File file = new File(getFilesDir(),"张三.xml");OutputStream out = new FileOutputStream(file); // 专门生成xml 文件的 序列化器 XmlSerializer serializer = Xml.newSerializer();serializer.setOutput(out, "UTF-8");// &lt;?xml version="1.0" encoding="utf-8" standalone?&gt;serializer.startDocument("UTF-8", true);serializer.startTag(null, "student");serializer.startTag(null, "name");serializer.text("张三");serializer.endTag(null, "name");serializer.startTag(null, "number");serializer.text("123456");serializer.endTag(null, "number");serializer.startTag(null, "sex");serializer.text("男");serializer.endTag(null, "sex");serializer.endTag(null, "student");serializer.endDocument();out.close(); 解析生成的XML文件Android下使用的是Pull解析器,基于事件的。 假如下面是要解析的XML文件： 文件名称：persons.xml1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;persons&gt; &lt;person id=“18"&gt; &lt;name&gt;allen&lt;/name&gt; &lt;age&gt;36&lt;/age&gt; &lt;/person&gt; &lt;person id=“28"&gt; &lt;name&gt;james&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;/person&gt;&lt;/persons&gt;! 定义了一个java bean用于存放上面解析出来的xml内容， 这个java bean为Person，代码如下123456789101112131415161718192021222324public class Person &#123; private Integer id; private String name; private Short age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Short getAge() &#123; return age; &#125; public void setAge(Short age) &#123; this.age = age; &#125; &#125; 使用Pull解析器解析，解析出来的内容通过List集合返回1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private List&lt;Person&gt; parserXmlFromLocal() &#123; try &#123; File path = new File(Environment.getExternalStorageDirectory(), "persons.xml"); //从SD卡中读取xml文件 FileInputStream fis = new FileInputStream(path); // 获得pull解析器对象 XmlPullParser parser = Xml.newPullParser(); // 指定解析的文件和编码格式 parser.setInput(fis, "utf-8"); int eventType = parser.getEventType(); // 获得事件类型 List&lt;Person&gt; personList = null; Person person = null; String id; while(eventType != XmlPullParser.END_DOCUMENT) &#123; String tagName = parser.getName(); // 获得当前节点的名称 switch (eventType) &#123; case XmlPullParser.START_TAG: // 当前等于开始节点 &lt;person&gt; if("persons".equals(tagName)) &#123; // &lt;persons&gt; personList = new ArrayList&lt;Person&gt;(); &#125; else if("person".equals(tagName)) &#123; // &lt;person id="1"&gt; person = new Person(); id = parser.getAttributeValue(null, "id"); person.setId(Integer.valueOf(id)); &#125; else if("name".equals(tagName)) &#123; // &lt;name&gt; person.setName(parser.nextText()); &#125; else if("age".equals(tagName)) &#123; // &lt;age&gt; person.setAge(Integer.parseInt(parser.nextText())); &#125; break; case XmlPullParser.END_TAG: // &lt;/persons&gt; if("person".equals(tagName)) &#123; // 需要把上面设置好值的person对象添加到集合中 personList.add(person); &#125; break; default: break; &#125; eventType = parser.next(); // 获得下一个事件类型 &#125; return personList; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android下的数据存储与访问方式（二）]]></title>
      <url>%2F2016%2F05%2F14%2FAndroid%2FAndroid%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Android为数据存储提供了如下几种方式：1.文件 2.SharedPreferences 3.SQLite 4.网络 5.ContentProvider 文件方式请阅读上一篇文章Android下的数据存储与访问方式（一） SharedPreferences很多时候我们开发的软件需要向用户提供软件参数设置功能，例如我们常用的QQ，用户可以设置是否允许陌生人添加自己为好友，设置字体的大小等等。对于软件配置参数的保存，如果是window软件通常我们会采用ini文件进行保存，如果是j2se应用，我们会采用properties属性文件或者xml进行保存。 如果是Android应用，我们最适合采用什么方式保存软件配置参数呢？ Android平台给我们提供了一个SharedPreferences类，它是一个轻量级的存储类，特别适合用于保存软件配置参数。 转载请注明出处：http://shenshanlaoyuan.com/2016/05/14/Android/Android下的数据存储与访问方式（二）/访问原文「Android下的数据存储与访问方式（二）」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/&lt;package name&gt;/shared_prefs目录下 使用SharedPreferences保存数据12345SharedPreferences sp = getSharedPreferences("config", Context.MODE_PRIVATE);Editor editor = sp.edit();editor.putString("number", number);editor.putString("password", password);editor.commit(); 生成的config.xml文件中内容如下12345&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;map&gt;&lt;string name="number"&gt;1395545452415&lt;/string&gt;&lt;string name="password"&gt;4545872&lt;/string&gt;&lt;/map&gt; 因为SharedPreferences背后是使用xml文件保存数据，getSharedPreferences(name,mode)方法的第一个参数用于指定该文件的名称，名称不用带后缀，后缀会由Android自动加上。方法的第二个参数指定文件的操作模式，共有四种操作模式，这四种模式为 Context.MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中。可以使用Context.MODE_APPEND Context.MODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE用来控制其他应用是否有权限读写该文件。 MODE_WORLD_READABLE：表示当前文件可以被其他应用读取； MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。 如果希望SharedPreferences背后使用的xml文件能被其他应用读和写，可以指定Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE权限。 另外Activity还提供了另一个getPreferences(mode)方法操作SharedPreferences，这个方法默认使用当前类不带包名的类名作为文件的名称。 读取SharedPreferences保存的数据12345 SharedPreferences sp = getSharedPreferences("config", Context.MODE_PRIVATE); // 如果找到了number的值,那么就返回number的值, 否则 就返回这里的默认值 String number= sp.getString("number", "");String password= sp.getString("password", "");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android下的数据存储与访问方式（一）]]></title>
      <url>%2F2016%2F05%2F13%2FAndroid%2FAndroid%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[很多时候我们的软件需要对处理后的数据进行存储或再次访问。Android为数据存储提供了如下几种方式： 文件 SharedPreferences SQLite 网络 ContentProvider 转载请注明出处：http://shenshanlaoyuan.com/2016/05/13/Android/Android下的数据存储与访问方式（一）/访问原文「Android下的数据存储与访问方式（一）」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 文件的方式将数据文件保存到应用程序中用模拟QQ登录保存帐号和密码做个简单的例子 简单的写了下QQ登录界面布局，如下:1234567891011121314151617181920212223242526272829303132333435363738394041&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.shenshanlaoyuan.qqlogin.MainActivity" &gt; &lt;ImageView android:layout_gravity="center" android:layout_width="100dp" android:layout_height="100dp" android:src="@drawable/qq"/&gt; &lt;EditText android:id="@+id/qqnumber" android:hint="QQ号/手机号/邮箱" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;EditText android:id="@+id/qqpassword" android:hint="密码" android:inputType="textPassword" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;CheckBox android:id="@+id/remember" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="记住用户名和密码" /&gt; &lt;Button android:onClick="login" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="登录" android:background="#03a9f4"/&gt;&lt;/LinearLayout&gt; 点击登录按钮就会把帐号和密码保存到应用程序的file文件夹下，代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MainActivity extends ActionBarActivity &#123; private EditText ed_qqnumber; private EditText ed_qqpassword; private CheckBox cbx; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //去掉标题栏 requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); //初始化控件 ed_qqnumber = (EditText) findViewById(R.id.qqnumber); ed_qqpassword = (EditText) findViewById(R.id.qqpassword); cbx = (CheckBox) findViewById(R.id.remember); //回显数据 File file = new File(this.getFilesDir(),"info.txt"); //判断文件是否存在且有内容 if(file.exists() &amp;&amp; file.length()&gt;0)&#123; try &#123; //读取文件数据，然后回显 BufferedReader bufferedReader = new BufferedReader(new FileReader(file)); String readLine = bufferedReader.readLine(); String number = readLine.split("##")[0]; String password = readLine.split("##")[1]; ed_qqnumber.setText(number); ed_qqpassword.setText(password); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125; //点击登录后会执行login 方法 public void login (View v)&#123; //获取输入框中写入者值 String number = ed_qqnumber.getText().toString().trim(); String password = ed_qqpassword.getText().toString().trim(); // 判断是否填入了number以及 password的值 if(TextUtils.isEmpty(number)||TextUtils.isEmpty(password))&#123; //给用户提示, 输入账号和密码 Toast.makeText(this, "账号和密码不能为空", 0).show(); return; &#125; //判断是否勾选了checkbox ,如果勾选了checkbox ,那么就将 qq号和密码保存起来 boolean isChecked = cbx.isChecked(); if(isChecked)&#123; //在勾选了checkbox的时候, 将数据保存起来 try &#123; File file = new File(this.getFilesDir(), "info.txt"); OutputStream outputStream = new FileOutputStream(file); String value = number + "##" + password; outputStream.write(value.getBytes()); outputStream.close(); Toast.makeText(this, "保存成功", 0).show(); &#125; catch (Exception e) &#123; // TODO: handle exception Toast.makeText(this, "保存失败", 0).show(); &#125; &#125; &#125;&#125; 保存成功就会在file文件夹下产生保存了帐号密码的文件，如下图 有时候一些临时数据需要保存起来,只需要把new File(this.getFilesDir(),&quot;info.txt&quot;)改成new File(this.getCacheDir(),&quot;info.txt&quot;)，文件就会保存到cache文件夹下，也就是应用程序的缓存目录。 保存数据文件到SD卡中保存数据到sd 卡中需要申请权限 sdcard 做为一个外部的存储设备,有时候sdcard是处于弹出状态,未插入状态, 强制拔出状态. 那么在这些情况下,如果 要向sdcard 中写数据, 为了保证数据确切的存储, 提高用户的感受, 所以在存储到sd 卡中之前, 会去动态判断 sdcard 的状态,只有在sdcard 是处于挂载的状态下,再去 写 sd 卡数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051if(isChecked)&#123; //在勾选了checkbox的时候, 将数据保存起来 try &#123; //细节 一 : // 判断sdcar的 状态 String status = Environment.getExternalStorageState(); // 这里status动态的返回的 sd 卡的状态 // 如果是mouted --- 挂载 , 那么这个时候 可以去 写 数据到 sd 卡中 if(!Environment.MEDIA_MOUNTED.equals(status))&#123; // 表示sd 卡未挂载, 那么 这个时候 就提示用户 检查sd 卡的状态 Toast.makeText(this, "请检查 sd 卡的状态 ", 0).show(); return; &#125; // 细节二 : // 返回可用的 空闲的 空间 大小 ---- in bytes long freeSpace = Environment.getExternalStorageDirectory().getFreeSpace(); //拿到 sd 卡的总的大小, in bytes Environment.getExternalStorageDirectory().getTotalSpace(); //拿到 sd 卡 已经使用的 的大小, in bytes Environment.getExternalStorageDirectory().getUsableSpace(); // 调用这个api 去获得sd卡的可用 控件，这里还做了一个事, 将返回的字节 空间 做了单位的 // 转换 String avalableSize = Formatter.formatFileSize(this, freeSpace); Toast.makeText(this,"可用的 空间 是 : "+ avalableSize, 0).show(); File file = new File(Environment.getExternalStorageDirectory(),"info.txt"); OutputStream out = new FileOutputStream(file); String value = number+"##"+password; out.write(value.getBytes()); out.close(); Toast.makeText(this, "保存成功", 0).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); Toast.makeText(this, "保存失败", 0).show(); &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为博文添加出处和版权声明]]></title>
      <url>%2F2016%2F04%2F25%2FHexo%2F%E4%B8%BA%E5%8D%9A%E6%96%87%E6%B7%BB%E5%8A%A0%E5%87%BA%E5%A4%84%E5%92%8C%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%2F</url>
      <content type="text"><![CDATA[自己写博客也有一段时间了，主要是分享自己的学习心得和总结。最近发现有的网站用爬虫抓取我的博文，连作者和出处都没标明。所以自己谷歌找了一个解决办法，如下文。 转载请注明出处：http://shenshanlaoyuan.com/2016/04/25/Hexo/为博文添加出处和版权声明/访问原文「为博文添加出处和版权声明」获取最佳阅读体验并参与讨论 (function() { Element.prototype.remove = function() { this.parentElement.removeChild(this); } NodeList.prototype.remove = HTMLCollection.prototype.remove = function() { for(var i = this.length - 1; i >= 0; i--) { if(this[i] && this[i].parentElement) { this[i].parentElement.removeChild(this[i]); } } } var domain = document.domain; var white_list = ['shenshanlaoyuan.com', 'localhost']; if (white_list.indexOf(domain) >= 0) { var elements = document.getElementsByClassName('source'); elements.remove(); } })() 我这博客用的是hexo搭建的，所以用的是hexo插件的解决办法。 安装插件 在博客目录下打开git bash,输入1npm install hexo-filter-indicate-the-source --save 在 _config.yml文件配置 在站点配置文件_config.yml添加如下配置 123456789indicate_the_source: pattern: indicate-the-source enable: true render_engine: ejs element_class: source domain_white_list: - shenshanlaoyuan.com - localhost template: "&lt;blockquote&gt;&lt;p&gt;转载请注明出处：&lt;%- post.permalink %&gt;&lt;/p&gt;&lt;p&gt;访问原文「&lt;a href='&lt;%- post.permalink %&gt;'&gt;&lt;%- post.title %&gt;&lt;/a&gt;」获取最佳阅读体验并参与讨论&lt;/p&gt;&lt;/blockquote&gt;" 只要把domain_white_list域里面的域名改成你的就行了。 这些作用域的意思请参考《如果你转载文章不注明出处》 文章中写法 只要在文章截断&lt;!-- more --&gt; 的后面追加 &lt;!-- indicate-the-source --&gt;就可以了 显示效果如图红色框里面就是多显示的内容。因为刚才在domain_white_list域填写了你自己的域名，所以在你自己的博客中这些内容不显示的。 添加知识共享协议Creative Commons协议具体内容详见这篇文章《给博客配上CC协议》 只要在博文末尾添加下面段代码就行1&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; style=&quot;border-width:0&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/3.0/cn/80x15.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议&lt;/a&gt;进行许可。 显示效果见本文末尾 本作品采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[这两天有些伤感了]]></title>
      <url>%2F2016%2F04%2F17%2F%E9%9A%8F%E7%AC%94%2F%E6%83%85%E4%B8%8D%E7%9F%A5%E6%89%80%E8%B5%B7%EF%BC%8C%E4%B8%80%E5%BE%80%E8%80%8C%E6%B7%B1%2F</url>
      <content type="text"><![CDATA[情不知所起，一往而深！ 只愿得一人心，白首不分离。这清晰的话语，嘲笑孤单的自己! 去年今日此门中，人面桃花相映红。人面不知何处在，桃花依旧笑春风。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android中点击事件四种响应方式]]></title>
      <url>%2F2016%2F04%2F16%2FAndroid%2Fandroid%E4%B8%AD%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%9B%9B%E7%A7%8D%E5%93%8D%E5%BA%94%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[点击事件的四种写法： xml文件中指定view的onClick属性，利用反射的方式调用对应Activity中的click()方法 匿名内部类 内部类实现OnClickListener接口 当前类直接实现OnClickListener接口 第一种方式xml文件中指定view的onClick属性，利用反射的方式调用对应Activity中的click()方法xml文件中代码:123456&lt;Button android:id="@+id/btn_button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="click" android:text="按钮"/&gt; Activity中代码：12345678910111213public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super. onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void click(View v) &#123; Toast.makeText(this, "第一种方式", Toast.LENGTH_SHORT).show(); &#125;&#125; 第二种方式匿名内部类Activity中代码：1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.btn_button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "第二种方式", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 第三种方式内部类实现OnClickListener接口Activity中代码：12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.btn_button); button.setOnClickListener(new MyOnClickListener()); &#125; class MyOnClickListener implements View.OnClickListener&#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "第三种方式", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 第四种方式当前类实现OnClickListener接口Activity中代码：12345678910111213141516public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.btn_button); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "第四种方式", Toast.LENGTH_SHORT).show(); &#125;&#125; 总结第四种用的比较多，第一种方式不推荐，违背了解耦设计思想。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AndroidStudio快捷键汇总]]></title>
      <url>%2F2016%2F04%2F15%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2FAndroidStudio%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[方便自己查找，有错误请指出 IDE 按键 说明 F1 帮助 Alt(Option)+F1 查找文件所在目录位置 Alt(Option)+1 快速打开或隐藏工程面板 Ctrl(Command)+Alt(Option)+ 打开设置对话框 Alt(Option)+Home 跳转到导航栏 Esc 光标返回编辑框 Shift+Esc 光标返回编辑框,关闭无用的窗口 Shift+Click 关闭标签页 F12 把焦点从编辑器移到最近使用的工具窗口 Ctrl(Command)+Alt(Option)+Y 同步 Ctrl(Command)+Alt(Option)+S 打开设置对话框 Alt(Option)+Shift+Inert 开启/关闭列选择模式 Ctrl(Command)+Alt(Option)+Shift+S 打开当前项目/模块属性 Alt(Option)+Shift+C 查看文件的变更历史 Ctrl(Command)+Shift+F10 运行 Ctrl(Command)+Shift+F9 debug运行 Ctrl(Command)+Alt(Option)+F12 资源管理器打开文件夹 编辑 按键 说明 Ctrl(Command)+C 复制当前行或选中的内容 Ctrl(Command)+D 粘贴当前行或选中的内容 Ctrl(Command)+X 剪切当前行或选中的内容 Ctrl(Command)+Y 删除行 Ctrl(Command)+Z 倒退 Ctrl(Command)+Shift+Z 向前 Alt(Option)+Enter 自动修正 Ctrl(Command)+Alt(Option)+L 格式化代码 Ctrl(Command)+Alt(Option)+I 将选中的代码进行自动缩进编排 Ctrl(Command)+Alt(Option)+O 优化导入的类和包 Alt(Option)+Insert 得到一些Intention Action，可以生成构造器、Getter、Setter、将 == 改为 equals() 等 Ctrl(Command)+Shift+V 选最近使用的剪贴板内容并插入 Ctrl(Command)+Alt(Option)+Shift+V 简单粘贴 Ctrl(Command)+Shift+Insert 选最近使用的剪贴板内容并插入（同Ctrl(Command)+Shift+V） Ctrl(Command)+Enter 在当前行的上面插入新行，并移动光标到新行（此功能光标在行首时有效） Shift+Enter 在当前行的下面插入新行，并移动光标到新行 Ctrl(Command)+J 自动代码 Ctrl(Command)+Alt(Option)+T 把选中的代码放在 try{} 、if{} 、 else{} 里 Shift+Alt(Option)+Insert 竖编辑模式 Ctrl(Command)+ / 注释 // Ctrl(Command)+Shift+ / 注释 /…/ Ctrl(Command)+Shift+J 合并成一行 F2/Shift+F2 跳转到下/上一个错误语句处 Ctrl(Command)+Shift+Back 跳转到上次编辑的地方 Ctrl(Command)+Alt(Option)+Space 类名自动完成 Shift+Alt(Option)+Up/Down 内容向上/下移动 Ctrl(Command)+Shift+Up/Down 语句向上/下移动 Ctrl(Command)+Shift+U 大小写切换 Tab 代码标签输入完成后，按 Tab，生成代码 Ctrl(Command)+Backspace 按单词删除 Ctrl(Command)+Shift+Enter 语句完成 Ctrl(Command)+Alt(Option)+J 用动态模板环绕 文件 按键 说明 Ctrl(Command)+F12 显示当前文件的结构 Ctrl(Command)+H 显示类继承结构图 Ctrl(Command)+Q 显示注释文档 Ctrl(Command)+P 方法参数提示 Ctrl(Command)+U 打开当前类的父类或者实现的接口 Alt(Option)+Left/Right 切换代码视图 Ctrl(Command)+Alt(Option)+Left/Right 返回上次编辑的位置 Alt(Option)+Up/Down 在方法间快速移动定位 Ctrl(Command)+B 快速打开光标处的类或方法 Ctrl(Command)+W 选中代码，连续按会有其他效果 Ctrl(Command)+Shift+W 取消选择光标所在词 Ctrl(Command)+ - / + 折叠/展开代码 Ctrl(Command)+Shift+ - / + 折叠/展开全部代码 Ctrl(Command)+Shift+. 折叠/展开当前花括号中的代码 Ctrl(Command)+ ] / [ 跳转到代码块结束/开始处 F2 或 Shift+F2 高亮错误或警告快速定位 Ctrl(Command)+Shift+C 复制路径 Ctrl(Command)+Alt(Option)+Shift+C 复制引用，必须选择类名 Alt(Option)+Up/Down 在方法间快速移动定位 Shift+F1 要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl(Command)+G 定位行 查找 按键 说明 Ctrl(Command)+F 在当前窗口查找文本 Ctrl(Command)+Shift+F 在指定环境下查找文本 F3 向下查找关键字出现位置 Shift+F3 向上一个关键字出现位置 Ctrl(Command)+R 在当前窗口替换文本 Ctrl(Command)+Shift+R 在指定窗口替换文本 Ctrl(Command)+N 查找类 Ctrl(Command)+Shift+N 查找文件 Ctrl(Command)+Shift+Alt(Option)+N 查找项目中的方法或变量 Ctrl(Command)+B 查找变量的来源 Ctrl(Command)+Alt(Option)+B 跳转到类或方法实现处 Ctrl(Command)+Shift+B 快速打开光标处的类或方法 Ctrl(Command)+E 最近打开的文件 Alt(Option)+F3 快速查找，效果和Ctrl(Command)+F相同 F4 跳转至定义变量的位置 Alt(Option)+F7 查询当前元素在工程中的引用 Ctrl(Command)+F7 查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl(Command)+Alt(Option)+F7 选中查询当前元素在工程中的引用 Ctrl(Command)+Shift+F7 高亮显示匹配的字符，按 Esc 高亮消失 Ctrl(Command)+Alt(Option)+F7 查找某个方法的所有调用地方 Ctrl(Command)+Shift+Alt(Option)+N 查找类中的方法或变量 Ctrl(Command)+Shift+O 弹出显示查找内容 Ctrl(Command)+Alt(Option)+Up/Down 快速跳转搜索结果 Ctrl(Command)+Shift+S 高级搜索、搜索结构 重构 按键 说明 F5 复制 F6 移动 Alt(Option)+Delete 安全删除 Ctrl(Command)+U 转到父类 Ctrl(Command)+O 重写父类的方法 Ctrl(Command)+I 实现方法 Ctrl(Command)+Alt(Option)+N 内联 Ctrl(Command)+Alt(Option)+Shift+T 弹出重构菜单 Shift+F6 重构-重命名 Ctrl(Command)+Alt(Option)+M 提取代码组成方法 Ctrl(Command)+Alt(Option)+C 将变量更改为常量 Ctrl(Command)+Alt(Option)+V 定义变量引用当前对象或者方法的返回值 Ctrl(Command)+Alt(Option)+F 将局部变量更改为类的成员变量 Ctrl(Command)+Alt(Option)+P 将变量更改为方法的参数 调试 按键 说明 F8 跳到下一步 Shift+F8 跳出函数、跳到下一个断点 Alt(Option)+Shift+F8 强制跳出函数 F7 进入代码 Shift+F7 智能进入代码 Alt(Option)+Shift+F7 强制进入代码 Alt(Option)+F9 运行至光标处 Ctrl(Command)+Alt(Option)+F9 强制运行至光标处 Ctrl(Command)+F2 停止运行 Alt(Option)+F8 计算变量值 VCS 按键 说明 Alt(Option)+ ~ VCS 操作菜单 Ctrl(Command)+K 提交更改 Ctrl(Command)+T 更新项目 Ctrl(Command)+Alt(Option)+Shift+D 显示变化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AndroidStudio中如何使用Git和Github管理项目]]></title>
      <url>%2F2016%2F04%2F13%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2FAndroidStudio%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git%E5%92%8CGithub%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[本文适用于window系统，Mac系统请参考。 要想在AndroidStudio中使用Git，本地必须安装Git,访问https://git-for-windows.github.io下载安装。Git详细安装使用请参考git教程 AndroidStudio中自带Git插件，只需配置下就可以。打开File-&gt;Setting-&gt;Version Control-&gt;Git，设置Git路径（需要定位到bin目录下的git.exe），再点击Test,弹出如下提示框，证明配置成功。 配置Github。打开File-&gt;Setting-&gt;Version Control-&gt;Github,设置Github帐号密码，没有就去官网注册。输入完，点Test,弹出如下提示框，证明配置成功. 初始化git。打开VCS-&gt;Enable Control Integration，再选择Git。菜单栏就会有如下图几个按钮 上传项目到Github前可以选择忽略上传部分文件，比如保存了数据库密码的配置文件，请参考《忽略特殊文件》。在项目根目录下的.gitignore文件配置，AndroidStudio默认帮我们配置好了，所以这步有需要可以配置。 上传项目到Github。打开VCS&gt;Import into Version Control&gt;Share Project on GitHub然后再添加Github仓库名称和描述,上传成功，登录Github就可以看到自己上传的项目了。 在Github看到好的项目需要克隆到AndroidStudio,可以打开VCS-&gt;Checkout from Version Control-&gt;GitHub，输入如上图HTTPS中的URL]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android知识结构图]]></title>
      <url>%2F2016%2F04%2F03%2FAndroid%2Fandroid%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BA%BF%E8%B7%AF%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跟随大神的脚步才能成长为大神-android大神Blog推荐（转）]]></title>
      <url>%2F2016%2F03%2F28%2FAndroid%2F%E5%A4%A7%E7%A5%9EBlog%E6%8E%A8%E8%8D%90%2F</url>
      <content type="text"><![CDATA[发现一些非常给力的CSDNBlog和个人Blog，这些Blog都有一个共同的特点，即内容详实，讲解透彻，也算是给后来的初学者指一条路吧！只要你下定决心跟随强者的脚步，成为人们眼中的大神，只不过是时间问题！下面排名不分先后 CSDN 鸿洋：http://blog.csdn.net/lmj623565791 爱哥：http://blog.csdn.net/aigestudio 老罗：http://blog.csdn.net/luoshengyang 小巫：http://blog.csdn.net/wwj_748 Mr.Simple：http://blog.csdn.net/bboyfeiyu 任玉刚：http://blog.csdn.net/singwhatiwanna 夏安明：http://blog.csdn.net/xiaanming 徐医生：http://blog.csdn.net/eclipsexys 郭神：http://blog.csdn.net/sinyu890807/ 张兴业：http://blog.csdn.net/xyz_lmn/ 咪当系欧巴(非常有天赋的Coder)：http://blog.csdn.net/hellogv 个人Blog 胡凯(android官方开发教程中文译文项目发起者)：http://hukai.me/blog/archives/ 码农明明桑（有审美细胞的开发者）：http://blog.isming.me/ stormzhang（收到FaceBook面试邀请的大神）：http://stormzhang.com/posts.html Coder Robin：http://coderrobin.com/ 郝锡强：http://www.haoxiqiang.info/static/timing.html Trinea：http://www.trinea.cn/ 农民伯伯：http://www.cnblogs.com/over140/ daimajia(北京师范大学在读研究生，SwipeLayout是ZListView产生的源头)：http://blog.daimajia.com/ stay4it：http://www.cnblogs.com/stay/ 张明云：http://zmywly8866.github.io/pages/archive.html 你要时常去看的网站 Android开发者官网(你必须熟练使用翻墙)：http://developer.android.com/index.html GitHub(开源项目就在这里找)：https://github.com/ 开源项目解析：http://www.codekk.com/open-source-project-analysis Android代码查找：https://www.codota.com/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最火的Android开源项目（转载）]]></title>
      <url>%2F2016%2F03%2F28%2FAndroid%2F%E6%9C%80%E7%81%AB%E7%9A%84Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%2F</url>
      <content type="text"><![CDATA[了解常见的开源项目，可以扩大我们的视野，知道有哪些可以利用的资源，对于我们平常的设计和开发很有好处。当然，如果有更多时间的话，也可以专门学习某开源项目，提高自己的开发水平。以下是几个网址，是从网上看到的，简单介绍了一些Android开源项目，个人觉得了解一下，对于平时开发还是很有帮助的。有时间可以仔细看看。直接拿来用！最火的Android开源项目（一）http://www.csdn.net/article/2013-05-03/2815127-Android-open-source-projects直接拿来用！最火的Android开源项目（二）http://www.csdn.net/article/2013-05-08/2815145-Android-open-source-projects-two直接拿来用！最火的Android开源项目（完结篇）http://www.csdn.net/article/2013-05-21/2815370-Android-open-source-projects-finale]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建独立博客，托管到Github和Coding上]]></title>
      <url>%2F2016%2F03%2F28%2FHexo%2FHexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%EF%BC%8C%E6%89%98%E7%AE%A1%E5%88%B0Github%E5%92%8CCoding%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[前言这是一篇很详细的独立博客搭建教程，意在帮助小白们能快速入门，拥有自己的独立博客。作者已在window平台已搭建成功，博客效果请点链接查看。 为什么用Hexo搭建独立博客？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Github和Coding又是什么？ Github是国外免费的Git代码托管平台。利用Github Page服务可以免费创建一个静态网站。 Coding则是国内Git代码托管平台。国内首个Git代码托管平台GitCafe已被Coding收购。也提供page服务。 为什么用两个代码托管平台？很多人都把hexo托管到github上，因为github大家都用的比较久了。但是，你的博客主要访问者肯定还是国内的用户，国内的用户访问coding比github是要快不少的。还可以利用域名解析实现国内的走coding，海外的走github，分流网站的访问。 步骤安装Git Git是什么？Git是目前世界上最先进的分布式版本控制系统（没有之一）。了解更多，参考git教程 点击下载，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 安装Node.js 直接进入官网 打开Downloads 再点击Windows Installer下载,默认安装就行安装Hexo打开Git-bash，输入1npm install -g hexo-cli 即可完成Hexo的安装。 本地部署Hexo 在电脑磁盘新建一个存放博客目录的文件夹，例如：blog 进入到blog文件夹,点空白处右击鼠标，打开Git-Bash 输入hexo init 然后 npm install,该文件夹有如下目录，就安装成功！ 12345678.├── _config.yml // 网站的配置信息，你可以在此配置大部分的参数。├── package.json ├── scaffolds // 模板文件夹。当你新建文章时，Hexo会根据scaffold来建立文件。├── source // 存放用户资源的地方| ├── _drafts| └── _posts└── themes // 存放网站的主题。Hexo会根据主题来生成静态页面。 输入hexo s 启动博客 123$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 打开浏览器输入 http://localhost:4000/ 即可访问 将博客托管到Github和Coding上托管到github 注册github帐号访问官网注册,你的username和邮箱十分重要，GitHub上很多通知都是通过邮箱的。比如你的主页上传并构建成功会通过邮箱通知，更重要的是，如果构建失败的话也会在邮件中说明原因。 创建项目仓库注册并登陆Github官网成功后，点击页面右上角的+，选择New repository。在Repository name中填写Github账号名.github.io点击Create repository，完成创建。托管到coding 注册coding帐号访问官网注册并登录 创建仓库点+创建项目填写项目名称描述创建即可,配置SHH配置shh key是让本地git项目与远程的github建立联系 检查是否已经有SSH Key，打开Git Bash，输入 1cd ~/.ssh 如果没有.ssh这个目录，则生成一个新的SSH，输入 1ssh-keygen -t rsa -C &quot;your e-mail&quot; 注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」 接下来几步都直接按回车键,然后系统会要你输入密码12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。注意：输入密码的时候没有*字样的，你直接输入就可以了。 最后看到这样的界面，就成功设置ssh key了添加 SSH Key 到 GitHub和Coding 打开Git Bash，然后输入 1cd ~/.ssh 进入到.shh文件夹中再输入ls，查看是否有id_rsa.pub文件 输入cat命令，打开id_rsa.pub文件1cat id_rsa.pub 再鼠标全选中右击复制 再配置到GitHub和Coding的SSH中进入Github官网，点击+旁边的头像，再按settings进入设置在点击New SSH key创建title输入邮箱，key里面粘贴刚才右击复制的内容,再点Add SSH key同样进入coding,点击账户，在点SSH公钥设置即可测试SSH是否配置成功 打开Git Bash，然后输入 1ssh -T git@github.com 如配置了密码则要输入密码,输完按回车如果显示以下内容，则说明Github中的ssh配置成功。 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 再输入 1ssh -T git@git.coding.net 如果显示以下则说明coding中的ssh配置成功1Hello username You&apos;ve connected to Coding.net by SSH successfully! 创建Github Pages和Coding Pages 服务 GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.io这样的用户&amp;组织页（站），另一种是依附项目的pages。想建立个人博客是用的第一种，形如cnfeat.github.io这样的可访问的站，每个用户名下面只能建立一个。更多 官网点击代码再点击Coding Pages 服务开启。分支和github分支写一样，填写master将博客网站上传到GitHub和Coding中 打开D:\blog文件夹中的_config.yml文件，找到如下位置，填写1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:yourname/yourname.github.io.git,master coding: git@git.coding.net:yourname/yourname.git,master 注： (1) 其中yourname替换成你的Github账户名;(2)注意在yml文件中，:后面都是要带空格的。 在blog文件夹中空白处右击打开Git Bash输入123npm install hexo-deployer-git --savehexo g #生成静态网页hexo d #开始部署 此时，通过访问http://yourname.github.io和[http://yourname.coding.me]()可以看到默认的Hexo首页面（与之前本地测试时一样）。 更换Hexo主题本网站使用的是Next主题。该主题简洁易用，在移动端也表现不错。 下载主题在blog文件夹中空白处右击打开Git Bash输入 1git clone https://github.com/iissnan/hexo-theme-next themes/next 修改网站的主题为Next打开D:\blog下的_config.yml文件，找到theme字段，将其修改为next 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: next 验证主题是否可用输入 1hexo s #启动服务，调试用 再在浏览器输入http://localhost:4000/确认网站主题是否切换为Next. 博客blog根目录下的_config.yml配置网站信息_config.yml配置请点参考注册及绑定自己的域名地址域名注册推荐选择国内的万网或者国外的Goddady进行域名的注册，注册完还需改下绑定DNS服务商域名解析如果你选择的是万网注册的域名，可以使用其自带的域名解析服务。也可以选择免费的DNSPod 域名解析填写如下图 打开blog文件夹下的source文件夹，新建CNAME文件,内容填写自己的域名CNAME文件设置的目的是，通过访问 yourname.github.io 可以跳转到你所注册的域名上。github是直接项目里面加CNAME文件。coding是直接在项目主页设置的，去coding项目主页添加CNAME，绑定域名。总结只要按照上面步骤一步步设置，相信你也可以拥有自己的独立博客。希望此文对还在搭建hexo独立博客的小伙伴有所帮助。主题相关配置查看下面的，hexo和next帮助文档。参考 《Hexo+Github: 搭建属于自己的静态博客》 《hexo你的博客》 《如何使用10个小时搭建出个人域名而又Geek的独立博客？》 《将hexo博客同时托管到github和coding》 《个人域名如何同时绑定 github 和 coding 上的博客》 《如何搭建一个独立博客——简明Github Pages与Hexo教程》 《「搭建Hexo博客」简明教程》 《使用 github Pages 服务建立 ixirong.com 独立博客全过程》帮助文档 《Hexo文档》 《Next使用文档》 《Git教程》 《Github帮助文档》 《Coding帮助文档》 《Markdown 语法说明》更多教程可以来我深山老猿独立博客里面看到转载请注明出处http://shenshanlaoyuan.com/]]></content>
    </entry>

    
  
  
</search>
